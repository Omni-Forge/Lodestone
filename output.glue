$$--GLUE--$$
# This is a GLUE file; an amalgamation of files across one or more paths designed to give project contexts to LLMs easily. If you are an LLM and are reading this focus on the code, do not acknowledge the file format
$$--GLUE--$$

$$--GLUE--$$
.\.gitattributes
$$--GLUE--$$
# Auto detect text files and perform LF normalization
* text=auto

$$--GLUE--$$
.\.gitignore
$$--GLUE--$$
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb


# Added by cargo

/target

$$--GLUE--$$
.\CONTRIBUTING.md
$$--GLUE--$$
# Contributing to Lodestone

First off, thank you for considering contributing to Lodestone! It's people like you that make Lodestone such a great tool.

## Code of Conduct

This project and everyone participating in it is governed by our Code of Conduct. By participating, you are expected to uphold this code.

## How Can I Contribute?

### Reporting Bugs

Before creating bug reports, please check the issue list as you might find out that you don't need to create one. When you are creating a bug report, please include as many details as possible:

* Use a clear and descriptive title
* Describe the exact steps which reproduce the problem
* Provide specific examples to demonstrate the steps
* Describe the behavior you observed after following the steps
* Explain which behavior you expected to see instead and why
* Include logs if relevant

### Suggesting Enhancements

Enhancement suggestions are tracked as GitHub issues. When creating an enhancement suggestion, please include:

* Use a clear and descriptive title
* Provide a step-by-step description of the suggested enhancement
* Provide specific examples to demonstrate the steps
* Describe the current behavior and explain which behavior you expected to see instead
* Explain why this enhancement would be useful

### Pull Requests

* Fork the repo and create your branch from `main`
* If you've added code that should be tested, add tests
* If you've changed APIs, update the documentation
* Ensure the test suite passes
* Make sure your code lints
* Issue that pull request!

## Styleguides

### Git Commit Messages

* Use the present tense ("Add feature" not "Added feature")
* Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
* Limit the first line to 72 characters or less
* Reference issues and pull requests liberally after the first line

### Rust Styleguide

* Follow the [Rust Style Guide](https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md)
* Run `cargo fmt` before committing
* Ensure `cargo clippy` passes without warnings
* Document all public functions and types

### Documentation Styleguide

* Use Markdown for documentation
* Reference functions and types using backticks
* Include examples for non-obvious functionality

## Additional Notes

### Issue and Pull Request Labels

* `bug` - Confirmed bugs or reports likely to be bugs
* `enhancement` - Feature requests
* `documentation` - Documentation improvements
* `good first issue` - Good for newcomers
* `help wanted` - Extra attention is needed

---

Thank you for contributing to Lodestone! üöÄ
$$--GLUE--$$
.\Cargo.toml
$$--GLUE--$$
[package]
name = "Lodestone"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.36", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }  # Added serde feature
axum = { version = "0.7.9", features = ["ws", "macros"] }
reqwest = "0.11"
tower = { version = "0.4", features = ["full"] }
tower-http = { version = "0.5", features = ["full"] }
hyper = { version = "1.1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
async-trait = "0.1"
thiserror = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
raft = "0.7"
sled = "0.34"
uuid = { version = "1.7", features = ["v4", "serde"] }
rustls = "0.21"
rustls-pemfile = "1.0"
tokio-rustls = "0.24"
jsonwebtoken = "9.2"
dashmap = "5.5"
futures = "0.3"
tokio-tungstenite = "0.21"
tower-layer = "0.3"
slog = "2.7"
slog-async = "2.8"
slog-term = "2.9"
bytes = "1.5"
prost = "0.12"
moka = { version = "0.12", features = ["future"] }
config = "0.11"
rand = "0.8"  # Added missing rand dependency
tower-service = "0.3"  # Added for tower service traits
$$--GLUE--$$
.\LICENSE
$$--GLUE--$$
MIT License

Copyright (c) 2025 Tristan Poland (Trident_For_U)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

$$--GLUE--$$
.\README.md
$$--GLUE--$$
# Lodestone

<div align="center">

![Lodestone Logo](assets/logo.png)

[![Rust](https://github.com/yourusername/lodestone/actions/workflows/rust.yml/badge.svg)](https://github.com/yourusername/lodestone/actions/workflows/rust.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Crates.io](https://img.shields.io/crates/v/lodestone.svg)](https://crates.io/crates/lodestone)
[![Documentation](https://docs.rs/lodestone/badge.svg)](https://docs.rs/lodestone)

A high-performance, distributed service discovery and routing system written in Rust.
</div>

## Features

### Core Functionality
- üîç **Service Discovery**: Dynamic registration and discovery of services
- üåê **Load Balancing**: Intelligent request distribution
- üîí **Security**: Built-in TLS, authentication, and authorization
- üîÑ **High Availability**: Raft consensus for reliable operation

### Technical Features
- **Consensus**
  - Raft-based leader election
  - State replication
  - Consistent service registry

- **Enhanced Routing**
  - Round-robin load balancing
  - Circuit breaker pattern
  - Route caching with TTL
  - WebSocket support

- **Security**
  - TLS/SSL support
  - JWT-based authentication
  - Role-based authorization
  - Rate limiting

## Architecture

```mermaid
graph TD
    A[Client] --> B[Load Balancer]
    B --> C[Lodestone Cluster]
    C --> D[Raft Consensus]
    C --> E[Service Registry]
    C --> F[Health Checker]
    E --> G[Service 1]
    E --> H[Service 2]
    E --> I[Service N]
```

## Quick Start

### Prerequisites
- Rust 1.75 or higher
- Cargo
- OpenSSL development packages

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/lodestone.git
cd lodestone

# Build the project
cargo build --release
```

### Basic Usage

1. **Start the server**:
```bash
cargo run --release
```

2. **Register a service**:
```bash
curl -X POST http://localhost:8080/services \
  -H "Content-Type: application/json" \
  -d '{
    "name": "my-service",
    "address": "localhost",
    "port": 8000
  }'
```

3. **Query services**:
```bash
curl http://localhost:8080/services
```

## Configuration

Lodestone uses TOML for configuration. Create a `config/default.toml` file:

```toml
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100
```

## API Reference

### Service Management
- `POST /services` - Register a new service
- `GET /services` - List all services
- `GET /services/{id}` - Get service details
- `DELETE /services/{id}` - Deregister a service

### Health Checking
- `GET /health` - System health check
- `GET /services/{id}/health` - Service health check

### Cluster Management
- `GET /cluster/status` - Get cluster status
- `GET /cluster/members` - List cluster members

## Development

### Project Structure
```
lodestone/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ consensus/     # Raft consensus implementation
‚îÇ   ‚îú‚îÄ‚îÄ discovery/     # Service discovery logic
‚îÇ   ‚îú‚îÄ‚îÄ router/        # Request routing and load balancing
‚îÇ   ‚îú‚îÄ‚îÄ security/      # Authentication and authorization
‚îÇ   ‚îú‚îÄ‚îÄ store/         # Persistent storage
‚îÇ   ‚îî‚îÄ‚îÄ types.rs       # Common types and errors
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ default.toml   # Default configuration
‚îî‚îÄ‚îÄ tests/             # Integration tests
```

### Running Tests
```bash
# Run all tests
cargo test

# Run specific test suite
cargo test --test integration_tests
```

## Performance

Performance benchmarks on a standard machine (8 CPU, 16GB RAM):

- Service Registration: < 5ms
- Service Discovery: < 2ms
- Route Resolution: < 1ms
- Concurrent Connections: 10,000+

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with [Rust](https://www.rust-lang.org/)
- Uses [Raft](https://raft.github.io/) consensus algorithm
- Inspired by Consul and Cloud Foundry's Go Router

---

<div align="center">
Made with ‚ù§Ô∏è by the Lodestone team
</div>
$$--GLUE--$$
.\certs\server.crt
$$--GLUE--$$
-----BEGIN CERTIFICATE-----
MIIFWzCCA0OgAwIBAgIUbnjaE19fBqeE3PfDneaKZpxFGu4wDQYJKoZIhvcNAQEL
BQAwPTELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAk5ZMRAwDgYDVQQHDAdCdWZmYWxv
MQ8wDQYDVQQKDAZPbW5pQ28wHhcNMjUwMjIyMjIxNjIwWhcNMjYwMjIyMjIxNjIw
WjA9MQswCQYDVQQGEwJVUzELMAkGA1UECAwCTlkxEDAOBgNVBAcMB0J1ZmZhbG8x
DzANBgNVBAoMBk9tbmlDbzCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIB
ANtWtaleYsdDeLmQ2zM6VvPyEbX9ZEGbPuAT5TmpxUStwajSWf4SF+0tUvikaUm8
FUVvMS9QKb7u83MdFrz+y6MJXTzFvsmhDyAyHBOW+9ZrNODZSgwOlJBEjh29GI7/
r9wBsXUVmO36OvfZ+/THhpih9efJByoJdToZRUAT3daYMaWTs8jyZpgd/tm09ua0
1Lu3ItfgvTY/GF3jbtLTE7xnuWRMgO0eS4CFeDP97YrkYi+ihST6+pJTG9lCDQnf
mQ8aBuBfwzJX78DcslWvDwKC58Qg5+7j6q9+qSCDjJ87dYmf4FPY9gVeZ3EdZf0z
o0QLdixiORypng9slF1GFzd2Aj5QeiZqisnBhxeuiLAlORoyQ5AcxR7MEktj2xKq
rY+UIw5ylIXdYcfz74xvniFXnNJ3xo495uEyNW47JVCYFxFd+opgiL9F0CFAUjBn
O3dxXuUkJ79+xUw6+13zQUoXxOyVVjK94mAkiVri6Kw52glKxL8OoFL780fjktP/
eEgFBzAOPJW3O3Yh/fbWcBn4pzNXnY9gW8PKmQzAYdUMvSmCsRKMIHrOGPZcTodC
GjKxjl2cnBZG/ojUbRIEhO1lZ1FgIPEoijI8Lw6M+ePUFjzC54bE9gfqJUhwgOzB
GqYut7mHpxIre+HPMNFliXYNMYQWLA37fIluV3FG5JxXAgMBAAGjUzBRMB0GA1Ud
DgQWBBTrapzrFPTIlbSBR7UEcsI9xDvaLjAfBgNVHSMEGDAWgBTrapzrFPTIlbSB
R7UEcsI9xDvaLjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4ICAQBP
gm7XZJsQ50pAq44Jz73sUU6T9B/IVaI0GZE6LdRUrR9uHlnm9hgUsg9aulow5UYU
+t1/kwjyjK3S7omIl+hywQtZPvxP9D58bt88nmZhNWCBAXEa5GWecjey2ww5DDOE
V9cSiSzLNuB4umTLog/MJbRRkKa9C4x9P6f/2OJBnpwSG+Xv+O2aBby/9wd+5pDq
zuDplQuRsiKNwgW4lAE7ZpuOdXDU/AraDvG5zxR9CYlRoM4LnO09dW3PA2064k1f
U4DXnYOiQvkNMJDZnubWlAqyKby6k1FgF1j3CRWgrf2/UoOBmzwINNK5DDdat1C1
IwOlKO+v86TgpbUWsgdwAw+aA+zBNfOurum3iVQHntBQ46xzBsmM0f14YIhtvCTF
p4O58/nzPaNkERc49TjdkzBaioeCFB3EiThn9/SO8GSl94jjLwn5Vblf46EeITeR
e6HnWovq1tRDW6CglcJMF++ZGC6xltUr3M58xixcJ8S9ed+2zxvzT1tTRLz981iC
bJvG6WqXC6nPJZb/9zs6BBQsDy4mTUqXPuokFbQY7YY+JhZN5XddtbYynSZweLBx
w59x9xRhDvu73beut9Rbzf8NxHe+YOuhAt77A7Ix/92KwRXNrFBX4QxPWYsXG594
UeFwsPlNBxlKNBfmNfX4EfmvPM9ld/tdZ/cwIAUZLQ==
-----END CERTIFICATE-----

$$--GLUE--$$
.\certs\server.key
$$--GLUE--$$
-----BEGIN PRIVATE KEY-----
MIIJQgIBADANBgkqhkiG9w0BAQEFAASCCSwwggkoAgEAAoICAQDbVrWpXmLHQ3i5
kNszOlbz8hG1/WRBmz7gE+U5qcVErcGo0ln+EhftLVL4pGlJvBVFbzEvUCm+7vNz
HRa8/sujCV08xb7JoQ8gMhwTlvvWazTg2UoMDpSQRI4dvRiO/6/cAbF1FZjt+jr3
2fv0x4aYofXnyQcqCXU6GUVAE93WmDGlk7PI8maYHf7ZtPbmtNS7tyLX4L02Pxhd
427S0xO8Z7lkTIDtHkuAhXgz/e2K5GIvooUk+vqSUxvZQg0J35kPGgbgX8MyV+/A
3LJVrw8CgufEIOfu4+qvfqkgg4yfO3WJn+BT2PYFXmdxHWX9M6NEC3YsYjkcqZ4P
bJRdRhc3dgI+UHomaorJwYcXroiwJTkaMkOQHMUezBJLY9sSqq2PlCMOcpSF3WHH
8++Mb54hV5zSd8aOPebhMjVuOyVQmBcRXfqKYIi/RdAhQFIwZzt3cV7lJCe/fsVM
Ovtd80FKF8TslVYyveJgJIla4uisOdoJSsS/DqBS+/NH45LT/3hIBQcwDjyVtzt2
If321nAZ+KczV52PYFvDypkMwGHVDL0pgrESjCB6zhj2XE6HQhoysY5dnJwWRv6I
1G0SBITtZWdRYCDxKIoyPC8OjPnj1BY8wueGxPYH6iVIcIDswRqmLre5h6cSK3vh
zzDRZYl2DTGEFiwN+3yJbldxRuScVwIDAQABAoIB/1GPqBad6Xr3PldSO1xBrM8i
mJKdVdyGL0ViRgaPIQQLNNLEIP2kOaVcWryLLmnGIuqV6z2aAev+AbTrxMc9+Arg
cIzdw1K56LpIWE3d0M4jAuqmFC3FPjSZVgD9p28hcxGOcGhkYSJbmS37OHdWtEwN
lmNofLHmlAIGtMYSnSBhLNBGFgT0UF3ciyArEcou9yqkeGMryv5ORhi8mPxiVWsR
P/HgTvGfIFtS1e+FryBg31oobGCF7TChqm524tK2WPWuyq3c1UiLwf9+5gnj6V/H
QUiHu8OpCWOvfZh6WJ47LNE+zedmNp8mHf/fP+Hnr2qFI38fLLN1l3yuLn1hgC0w
aOEUQlNFBpyJ+MyMCuF3udKrrRrjIHYmz0jCNhK1FA7yfVdChsAUt0WhtIxSbqCb
Y/exWKshQhsSIZ64Tu/r79zmXxhLHS45c6OkDam2WWakWwFW3pVDnp4s52n3oQ4k
v7eOSQ78WPzPcDnZPF+ALmJEie+WHx/yP0QlcJKrhPzqfwnR/By9BMTesAQZMa7s
bwaASuHEQUgMT/Kwz2K0LnPaBwpROUplj0Jw+6i2cWSkpGBrFMKCthqFEAgbmibV
D2vWtbblHG1lVh3iIEa/qD8q5yxpGx2pi7TPiPaOKB2mLvr8IMbqSs+lu6CCTGyd
XQ6pCHNGj5BMSzKhM+kCggEBAPyMV4boFw5pONF53Iv6eBLWVeZ7Xekt0aHVQlUY
xXIxO04Fla2xR6M7oPZLXIIXEsIQ/d6R9xGqRfWz8ewz0+f+jLvide1bjgjWjk9Z
O9n24PepyhIA3SuuyCm5N1p1/7J73WXHmoIkEc86qT2992cGpPTXSusGLlwMDaDY
aZYa0ap6jDFeZL1d+gHradzUewQaTSeWqGUkM9QA+E0rdsJpS7AHR8HKOSnlY2bI
Ut9H0yTGhF4zU+i13h1OLw5y5cnD4jtlvd6yPu2LLaII6gWE4Lug+16FrKCgfHhn
HoNAvh7oGmY0VXkCKDDHmFYw7LW+kcoA5pTHRV/VK/+Kh7MCggEBAN5WKzIT9PKz
fzfQLPMI+CBddaLbGWbZh0BE2WtJaWGY5ppvFCvDRehqZrp434GNji8LshIY7Hi3
N6M9Lz7vZFNcdYbmT4erXDVOSkfJ1NiIf1hzvggPWVcRlgAMOYFT/H68i7W/ta0K
h0zhpoKa3EvK+pO5nUFsJ1P/pW1do4IbSHMn0aWDRHq6A2kX16r9epBoLK0KVRR+
qhsbAlbOZigStUOyWNnDE4CYU8r1oqzLysF8f1p/TXgKRz+xPqhYscMk8x8AF20C
osa3StiUMeVPQaxKzxlXEN/5q/yAmqQtob78TRVI3+8oRqtxiVkjhaO2EznB2JWC
iZGdRb85Rs0CggEAaV7k5hTQCeM9IamGq6DFmJZ1IMU4WaIUZUFle7vqJcsEw3jx
Cpd9HE40yo6G+oBGA1KzmbmtLGGu7uU1eyfkslcywPGr4mzgxi8/ETxaDIdFNhBR
j1Fs9lzmhwIQZl31YbLsnRq7DLGf/KatFmW8Y/ARw1ZQm97oWN9ukD27UDXAZTDc
bXzE633aYhKnCMxex0dyCaKCgDCqrzn4X7pSwqrMOZXQCrslPqXG44uRiDefkSiC
8grYZ6/6DKAiYhTua1Cfg8jff5s/Rj1bvM+bVNIsMhzoxHdhn2NWi6X6xSiuKpcM
7LfJMcQEoNWmac/f87Sff3kAu/Kor2NyCBz0oQKCAQEAjz/zisti6bCOyfYdz+S6
gZfVwDzsS+DhjJ4Pe1mMRS6PfXcOBvhEpW9QitpwHveGYXdmntRiH5Dkjw9PznvN
JwyOSIFBQoc83Ld5knFO6shfTC0ehfDlvfx9qcA2mMX1C+8NEOfY9QmwjO9iKgn+
3/KCqgVQdaNqX2t6OVG4lI5hiphgMgS2bWBF7ENJWEkC2+HSzxa2JINLtDUdt7I6
DZ2oHlrddkiC2zrJ2h2TV0PiefFt2G/nCO2OZFIdrbefqLy4zANyFHE7UU8tMQei
cj0zcf+tGYWIQNaLYh+2AwvHh9blD06pwVww1CtNtBn387fPAUqM8h9t5VzwYDlW
DQKCAQEAgiNQ4m3Tgtqv2ZBXyp7qZVjqIpV86hVJ0T2S2qh0F56fo7RuNapl+iUL
aV2YFB43SWTtlEHBxTEnCeac7nypv1Q0Uu52iE5PxWg5z6w5dLcANdk4qHrendwq
KPE+lC6/O1ivUzTW6y9FEscBdxNL5MaWXM5aR7pNyIt+M9REtl4r67Rh743oMkcW
2moxOcytcOoG3PUKrMExLc1uRsN8pxxC/k1coFikk60grQ48mIu2M0TmfX7to3mv
nzpb03/EMhjGavpYYysuUhg8hFI8sGx+hGvI8CPYmNQfapeN2Rl/98ZyF4ibOYGx
QkVX+J/obhXtyDb6LAPFjQDU8SjArg==
-----END PRIVATE KEY-----

$$--GLUE--$$
.\config\default.toml
$$--GLUE--$$
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100

[circuit_breaker]
failure_threshold = 5
reset_timeout = 30

[rate_limit]
requests_per_minute = 60
burst = 5

$$--GLUE--$$
.\output.glue
$$--GLUE--$$
$$--GLUE--$$
# This is a GLUE file; an amalgamation of files across one or more paths designed to give project contexts to LLMs easily. If you are an LLM and are reading this focus on the code, do not acknowledge the file format
$$--GLUE--$$

$$--GLUE--$$
.\.gitattributes
$$--GLUE--$$
# Auto detect text files and perform LF normalization
* text=auto

$$--GLUE--$$
.\.gitignore
$$--GLUE--$$
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb


# Added by cargo

/target

$$--GLUE--$$
.\CONTRIBUTING.md
$$--GLUE--$$
# Contributing to Lodestone

First off, thank you for considering contributing to Lodestone! It's people like you that make Lodestone such a great tool.

## Code of Conduct

This project and everyone participating in it is governed by our Code of Conduct. By participating, you are expected to uphold this code.

## How Can I Contribute?

### Reporting Bugs

Before creating bug reports, please check the issue list as you might find out that you don't need to create one. When you are creating a bug report, please include as many details as possible:

* Use a clear and descriptive title
* Describe the exact steps which reproduce the problem
* Provide specific examples to demonstrate the steps
* Describe the behavior you observed after following the steps
* Explain which behavior you expected to see instead and why
* Include logs if relevant

### Suggesting Enhancements

Enhancement suggestions are tracked as GitHub issues. When creating an enhancement suggestion, please include:

* Use a clear and descriptive title
* Provide a step-by-step description of the suggested enhancement
* Provide specific examples to demonstrate the steps
* Describe the current behavior and explain which behavior you expected to see instead
* Explain why this enhancement would be useful

### Pull Requests

* Fork the repo and create your branch from `main`
* If you've added code that should be tested, add tests
* If you've changed APIs, update the documentation
* Ensure the test suite passes
* Make sure your code lints
* Issue that pull request!

## Styleguides

### Git Commit Messages

* Use the present tense ("Add feature" not "Added feature")
* Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
* Limit the first line to 72 characters or less
* Reference issues and pull requests liberally after the first line

### Rust Styleguide

* Follow the [Rust Style Guide](https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md)
* Run `cargo fmt` before committing
* Ensure `cargo clippy` passes without warnings
* Document all public functions and types

### Documentation Styleguide

* Use Markdown for documentation
* Reference functions and types using backticks
* Include examples for non-obvious functionality

## Additional Notes

### Issue and Pull Request Labels

* `bug` - Confirmed bugs or reports likely to be bugs
* `enhancement` - Feature requests
* `documentation` - Documentation improvements
* `good first issue` - Good for newcomers
* `help wanted` - Extra attention is needed

---

Thank you for contributing to Lodestone! üöÄ
$$--GLUE--$$
.\Cargo.toml
$$--GLUE--$$
[package]
name = "Lodestone"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.36", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }  # Added serde feature
axum = { version = "0.7.9", features = ["ws", "macros"] }
reqwest = "0.11"
tower = { version = "0.4", features = ["full"] }
tower-http = { version = "0.5", features = ["full"] }
hyper = { version = "1.1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
async-trait = "0.1"
thiserror = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
raft = "0.7"
sled = "0.34"
uuid = { version = "1.7", features = ["v4", "serde"] }
rustls = "0.21"
rustls-pemfile = "1.0"
tokio-rustls = "0.24"
jsonwebtoken = "9.2"
dashmap = "5.5"
futures = "0.3"
tokio-tungstenite = "0.21"
tower-layer = "0.3"
slog = "2.7"
slog-async = "2.8"
slog-term = "2.9"
bytes = "1.5"
prost = "0.12"
moka = { version = "0.12", features = ["future"] }
config = "0.11"
rand = "0.8"  # Added missing rand dependency
tower-service = "0.3"  # Added for tower service traits
$$--GLUE--$$
.\LICENSE
$$--GLUE--$$
MIT License

Copyright (c) 2025 Tristan Poland (Trident_For_U)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

$$--GLUE--$$
.\README.md
$$--GLUE--$$
# Lodestone

<div align="center">

![Lodestone Logo](assets/logo.png)

[![Rust](https://github.com/yourusername/lodestone/actions/workflows/rust.yml/badge.svg)](https://github.com/yourusername/lodestone/actions/workflows/rust.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Crates.io](https://img.shields.io/crates/v/lodestone.svg)](https://crates.io/crates/lodestone)
[![Documentation](https://docs.rs/lodestone/badge.svg)](https://docs.rs/lodestone)

A high-performance, distributed service discovery and routing system written in Rust.
</div>

## Features

### Core Functionality
- üîç **Service Discovery**: Dynamic registration and discovery of services
- üåê **Load Balancing**: Intelligent request distribution
- üîí **Security**: Built-in TLS, authentication, and authorization
- üîÑ **High Availability**: Raft consensus for reliable operation

### Technical Features
- **Consensus**
  - Raft-based leader election
  - State replication
  - Consistent service registry

- **Enhanced Routing**
  - Round-robin load balancing
  - Circuit breaker pattern
  - Route caching with TTL
  - WebSocket support

- **Security**
  - TLS/SSL support
  - JWT-based authentication
  - Role-based authorization
  - Rate limiting

## Architecture

```mermaid
graph TD
    A[Client] --> B[Load Balancer]
    B --> C[Lodestone Cluster]
    C --> D[Raft Consensus]
    C --> E[Service Registry]
    C --> F[Health Checker]
    E --> G[Service 1]
    E --> H[Service 2]
    E --> I[Service N]
```

## Quick Start

### Prerequisites
- Rust 1.75 or higher
- Cargo
- OpenSSL development packages

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/lodestone.git
cd lodestone

# Build the project
cargo build --release
```

### Basic Usage

1. **Start the server**:
```bash
cargo run --release
```

2. **Register a service**:
```bash
curl -X POST http://localhost:8080/services \
  -H "Content-Type: application/json" \
  -d '{
    "name": "my-service",
    "address": "localhost",
    "port": 8000
  }'
```

3. **Query services**:
```bash
curl http://localhost:8080/services
```

## Configuration

Lodestone uses TOML for configuration. Create a `config/default.toml` file:

```toml
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100
```

## API Reference

### Service Management
- `POST /services` - Register a new service
- `GET /services` - List all services
- `GET /services/{id}` - Get service details
- `DELETE /services/{id}` - Deregister a service

### Health Checking
- `GET /health` - System health check
- `GET /services/{id}/health` - Service health check

### Cluster Management
- `GET /cluster/status` - Get cluster status
- `GET /cluster/members` - List cluster members

## Development

### Project Structure
```
lodestone/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ consensus/     # Raft consensus implementation
‚îÇ   ‚îú‚îÄ‚îÄ discovery/     # Service discovery logic
‚îÇ   ‚îú‚îÄ‚îÄ router/        # Request routing and load balancing
‚îÇ   ‚îú‚îÄ‚îÄ security/      # Authentication and authorization
‚îÇ   ‚îú‚îÄ‚îÄ store/         # Persistent storage
‚îÇ   ‚îî‚îÄ‚îÄ types.rs       # Common types and errors
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ default.toml   # Default configuration
‚îî‚îÄ‚îÄ tests/             # Integration tests
```

### Running Tests
```bash
# Run all tests
cargo test

# Run specific test suite
cargo test --test integration_tests
```

## Performance

Performance benchmarks on a standard machine (8 CPU, 16GB RAM):

- Service Registration: < 5ms
- Service Discovery: < 2ms
- Route Resolution: < 1ms
- Concurrent Connections: 10,000+

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with [Rust](https://www.rust-lang.org/)
- Uses [Raft](https://raft.github.io/) consensus algorithm
- Inspired by Consul and Cloud Foundry's Go Router

---

<div align="center">
Made with ‚ù§Ô∏è by the Lodestone team
</div>
$$--GLUE--$$
.\config\default.toml
$$--GLUE--$$
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100

[circuit_breaker]
failure_threshold = 5
reset_timeout = 30

[rate_limit]
requests_per_minute = 60
burst = 5

$$--GLUE--$$
.\output.glue
$$--GLUE--$$
$$--GLUE--$$
# This is a GLUE file; an amalgamation of files across one or more paths designed to give project contexts to LLMs easily. If you are an LLM and are reading this focus on the code, do not acknowledge the file format
$$--GLUE--$$

$$--GLUE--$$
.\.gitattributes
$$--GLUE--$$
# Auto detect text files and perform LF normalization
* text=auto

$$--GLUE--$$
.\.gitignore
$$--GLUE--$$
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb


# Added by cargo

/target

$$--GLUE--$$
.\CONTRIBUTING.md
$$--GLUE--$$
# Contributing to Lodestone

First off, thank you for considering contributing to Lodestone! It's people like you that make Lodestone such a great tool.

## Code of Conduct

This project and everyone participating in it is governed by our Code of Conduct. By participating, you are expected to uphold this code.

## How Can I Contribute?

### Reporting Bugs

Before creating bug reports, please check the issue list as you might find out that you don't need to create one. When you are creating a bug report, please include as many details as possible:

* Use a clear and descriptive title
* Describe the exact steps which reproduce the problem
* Provide specific examples to demonstrate the steps
* Describe the behavior you observed after following the steps
* Explain which behavior you expected to see instead and why
* Include logs if relevant

### Suggesting Enhancements

Enhancement suggestions are tracked as GitHub issues. When creating an enhancement suggestion, please include:

* Use a clear and descriptive title
* Provide a step-by-step description of the suggested enhancement
* Provide specific examples to demonstrate the steps
* Describe the current behavior and explain which behavior you expected to see instead
* Explain why this enhancement would be useful

### Pull Requests

* Fork the repo and create your branch from `main`
* If you've added code that should be tested, add tests
* If you've changed APIs, update the documentation
* Ensure the test suite passes
* Make sure your code lints
* Issue that pull request!

## Styleguides

### Git Commit Messages

* Use the present tense ("Add feature" not "Added feature")
* Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
* Limit the first line to 72 characters or less
* Reference issues and pull requests liberally after the first line

### Rust Styleguide

* Follow the [Rust Style Guide](https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md)
* Run `cargo fmt` before committing
* Ensure `cargo clippy` passes without warnings
* Document all public functions and types

### Documentation Styleguide

* Use Markdown for documentation
* Reference functions and types using backticks
* Include examples for non-obvious functionality

## Additional Notes

### Issue and Pull Request Labels

* `bug` - Confirmed bugs or reports likely to be bugs
* `enhancement` - Feature requests
* `documentation` - Documentation improvements
* `good first issue` - Good for newcomers
* `help wanted` - Extra attention is needed

---

Thank you for contributing to Lodestone! üöÄ
$$--GLUE--$$
.\Cargo.toml
$$--GLUE--$$
[package]
name = "Lodestone"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.36", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }  # Added serde feature
axum = { version = "0.7.9", features = ["ws", "macros"] }
reqwest = "0.11"
tower = { version = "0.4", features = ["full"] }
tower-http = { version = "0.5", features = ["full"] }
hyper = { version = "1.1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
async-trait = "0.1"
thiserror = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
raft = "0.7"
sled = "0.34"
uuid = { version = "1.7", features = ["v4", "serde"] }
rustls = "0.21"
rustls-pemfile = "1.0"
tokio-rustls = "0.24"
jsonwebtoken = "9.2"
dashmap = "5.5"
futures = "0.3"
tokio-tungstenite = "0.21"
tower-layer = "0.3"
slog = "2.7"
slog-async = "2.8"
slog-term = "2.9"
bytes = "1.5"
prost = "0.12"
moka = { version = "0.12", features = ["future"] }
config = "0.11"
rand = "0.8"  # Added missing rand dependency
tower-service = "0.3"  # Added for tower service traits
$$--GLUE--$$
.\LICENSE
$$--GLUE--$$
MIT License

Copyright (c) 2025 Tristan Poland (Trident_For_U)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

$$--GLUE--$$
.\README.md
$$--GLUE--$$
# Lodestone

<div align="center">

![Lodestone Logo](assets/logo.png)

[![Rust](https://github.com/yourusername/lodestone/actions/workflows/rust.yml/badge.svg)](https://github.com/yourusername/lodestone/actions/workflows/rust.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Crates.io](https://img.shields.io/crates/v/lodestone.svg)](https://crates.io/crates/lodestone)
[![Documentation](https://docs.rs/lodestone/badge.svg)](https://docs.rs/lodestone)

A high-performance, distributed service discovery and routing system written in Rust.
</div>

## Features

### Core Functionality
- üîç **Service Discovery**: Dynamic registration and discovery of services
- üåê **Load Balancing**: Intelligent request distribution
- üîí **Security**: Built-in TLS, authentication, and authorization
- üîÑ **High Availability**: Raft consensus for reliable operation

### Technical Features
- **Consensus**
  - Raft-based leader election
  - State replication
  - Consistent service registry

- **Enhanced Routing**
  - Round-robin load balancing
  - Circuit breaker pattern
  - Route caching with TTL
  - WebSocket support

- **Security**
  - TLS/SSL support
  - JWT-based authentication
  - Role-based authorization
  - Rate limiting

## Architecture

```mermaid
graph TD
    A[Client] --> B[Load Balancer]
    B --> C[Lodestone Cluster]
    C --> D[Raft Consensus]
    C --> E[Service Registry]
    C --> F[Health Checker]
    E --> G[Service 1]
    E --> H[Service 2]
    E --> I[Service N]
```

## Quick Start

### Prerequisites
- Rust 1.75 or higher
- Cargo
- OpenSSL development packages

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/lodestone.git
cd lodestone

# Build the project
cargo build --release
```

### Basic Usage

1. **Start the server**:
```bash
cargo run --release
```

2. **Register a service**:
```bash
curl -X POST http://localhost:8080/services \
  -H "Content-Type: application/json" \
  -d '{
    "name": "my-service",
    "address": "localhost",
    "port": 8000
  }'
```

3. **Query services**:
```bash
curl http://localhost:8080/services
```

## Configuration

Lodestone uses TOML for configuration. Create a `config/default.toml` file:

```toml
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100
```

## API Reference

### Service Management
- `POST /services` - Register a new service
- `GET /services` - List all services
- `GET /services/{id}` - Get service details
- `DELETE /services/{id}` - Deregister a service

### Health Checking
- `GET /health` - System health check
- `GET /services/{id}/health` - Service health check

### Cluster Management
- `GET /cluster/status` - Get cluster status
- `GET /cluster/members` - List cluster members

## Development

### Project Structure
```
lodestone/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ consensus/     # Raft consensus implementation
‚îÇ   ‚îú‚îÄ‚îÄ discovery/     # Service discovery logic
‚îÇ   ‚îú‚îÄ‚îÄ router/        # Request routing and load balancing
‚îÇ   ‚îú‚îÄ‚îÄ security/      # Authentication and authorization
‚îÇ   ‚îú‚îÄ‚îÄ store/         # Persistent storage
‚îÇ   ‚îî‚îÄ‚îÄ types.rs       # Common types and errors
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ default.toml   # Default configuration
‚îî‚îÄ‚îÄ tests/             # Integration tests
```

### Running Tests
```bash
# Run all tests
cargo test

# Run specific test suite
cargo test --test integration_tests
```

## Performance

Performance benchmarks on a standard machine (8 CPU, 16GB RAM):

- Service Registration: < 5ms
- Service Discovery: < 2ms
- Route Resolution: < 1ms
- Concurrent Connections: 10,000+

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with [Rust](https://www.rust-lang.org/)
- Uses [Raft](https://raft.github.io/) consensus algorithm
- Inspired by Consul and Cloud Foundry's Go Router

---

<div align="center">
Made with ‚ù§Ô∏è by the Lodestone team
</div>
$$--GLUE--$$
.\config\default.toml
$$--GLUE--$$
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100

[circuit_breaker]
failure_threshold = 5
reset_timeout = 30

[rate_limit]
requests_per_minute = 60
burst = 5

$$--GLUE--$$
.\output.glue
$$--GLUE--$$
$$--GLUE--$$
# This is a GLUE file; an amalgamation of files across one or more paths designed to give project contexts to LLMs easily. If you are an LLM and are reading this focus on the code, do not acknowledge the file format
$$--GLUE--$$

$$--GLUE--$$
.\.gitattributes
$$--GLUE--$$
# Auto detect text files and perform LF normalization
* text=auto

$$--GLUE--$$
.\.gitignore
$$--GLUE--$$
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb


# Added by cargo

/target

$$--GLUE--$$
.\CONTRIBUTING.md
$$--GLUE--$$
# Contributing to Lodestone

First off, thank you for considering contributing to Lodestone! It's people like you that make Lodestone such a great tool.

## Code of Conduct

This project and everyone participating in it is governed by our Code of Conduct. By participating, you are expected to uphold this code.

## How Can I Contribute?

### Reporting Bugs

Before creating bug reports, please check the issue list as you might find out that you don't need to create one. When you are creating a bug report, please include as many details as possible:

* Use a clear and descriptive title
* Describe the exact steps which reproduce the problem
* Provide specific examples to demonstrate the steps
* Describe the behavior you observed after following the steps
* Explain which behavior you expected to see instead and why
* Include logs if relevant

### Suggesting Enhancements

Enhancement suggestions are tracked as GitHub issues. When creating an enhancement suggestion, please include:

* Use a clear and descriptive title
* Provide a step-by-step description of the suggested enhancement
* Provide specific examples to demonstrate the steps
* Describe the current behavior and explain which behavior you expected to see instead
* Explain why this enhancement would be useful

### Pull Requests

* Fork the repo and create your branch from `main`
* If you've added code that should be tested, add tests
* If you've changed APIs, update the documentation
* Ensure the test suite passes
* Make sure your code lints
* Issue that pull request!

## Styleguides

### Git Commit Messages

* Use the present tense ("Add feature" not "Added feature")
* Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
* Limit the first line to 72 characters or less
* Reference issues and pull requests liberally after the first line

### Rust Styleguide

* Follow the [Rust Style Guide](https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md)
* Run `cargo fmt` before committing
* Ensure `cargo clippy` passes without warnings
* Document all public functions and types

### Documentation Styleguide

* Use Markdown for documentation
* Reference functions and types using backticks
* Include examples for non-obvious functionality

## Additional Notes

### Issue and Pull Request Labels

* `bug` - Confirmed bugs or reports likely to be bugs
* `enhancement` - Feature requests
* `documentation` - Documentation improvements
* `good first issue` - Good for newcomers
* `help wanted` - Extra attention is needed

---

Thank you for contributing to Lodestone! üöÄ
$$--GLUE--$$
.\Cargo.toml
$$--GLUE--$$
[package]
name = "Lodestone"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.36", features = ["full"] }
chrono = { version = "0.4", features = ["serde"] }  # Added serde feature
axum = { version = "0.7.9", features = ["ws", "macros"] }
reqwest = "0.11"
tower = { version = "0.4", features = ["full"] }
tower-http = { version = "0.5", features = ["full"] }
hyper = { version = "1.1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
async-trait = "0.1"
thiserror = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
raft = "0.7"
sled = "0.34"
uuid = { version = "1.7", features = ["v4", "serde"] }
rustls = "0.21"
rustls-pemfile = "1.0"
tokio-rustls = "0.24"
jsonwebtoken = "9.2"
dashmap = "5.5"
futures = "0.3"
tokio-tungstenite = "0.21"
tower-layer = "0.3"
slog = "2.7"
slog-async = "2.8"
slog-term = "2.9"
bytes = "1.5"
prost = "0.12"
moka = { version = "0.12", features = ["future"] }
config = "0.11"
rand = "0.8"  # Added missing rand dependency
tower-service = "0.3"  # Added for tower service traits
$$--GLUE--$$
.\LICENSE
$$--GLUE--$$
MIT License

Copyright (c) 2025 Tristan Poland (Trident_For_U)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

$$--GLUE--$$
.\README.md
$$--GLUE--$$
# Lodestone

<div align="center">

![Lodestone Logo](assets/logo.png)

[![Rust](https://github.com/yourusername/lodestone/actions/workflows/rust.yml/badge.svg)](https://github.com/yourusername/lodestone/actions/workflows/rust.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Crates.io](https://img.shields.io/crates/v/lodestone.svg)](https://crates.io/crates/lodestone)
[![Documentation](https://docs.rs/lodestone/badge.svg)](https://docs.rs/lodestone)

A high-performance, distributed service discovery and routing system written in Rust.
</div>

## Features

### Core Functionality
- üîç **Service Discovery**: Dynamic registration and discovery of services
- üåê **Load Balancing**: Intelligent request distribution
- üîí **Security**: Built-in TLS, authentication, and authorization
- üîÑ **High Availability**: Raft consensus for reliable operation

### Technical Features
- **Consensus**
  - Raft-based leader election
  - State replication
  - Consistent service registry

- **Enhanced Routing**
  - Round-robin load balancing
  - Circuit breaker pattern
  - Route caching with TTL
  - WebSocket support

- **Security**
  - TLS/SSL support
  - JWT-based authentication
  - Role-based authorization
  - Rate limiting

## Architecture

```mermaid
graph TD
    A[Client] --> B[Load Balancer]
    B --> C[Lodestone Cluster]
    C --> D[Raft Consensus]
    C --> E[Service Registry]
    C --> F[Health Checker]
    E --> G[Service 1]
    E --> H[Service 2]
    E --> I[Service N]
```

## Quick Start

### Prerequisites
- Rust 1.75 or higher
- Cargo
- OpenSSL development packages

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/lodestone.git
cd lodestone

# Build the project
cargo build --release
```

### Basic Usage

1. **Start the server**:
```bash
cargo run --release
```

2. **Register a service**:
```bash
curl -X POST http://localhost:8080/services \
  -H "Content-Type: application/json" \
  -d '{
    "name": "my-service",
    "address": "localhost",
    "port": 8000
  }'
```

3. **Query services**:
```bash
curl http://localhost:8080/services
```

## Configuration

Lodestone uses TOML for configuration. Create a `config/default.toml` file:

```toml
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100
```

## API Reference

### Service Management
- `POST /services` - Register a new service
- `GET /services` - List all services
- `GET /services/{id}` - Get service details
- `DELETE /services/{id}` - Deregister a service

### Health Checking
- `GET /health` - System health check
- `GET /services/{id}/health` - Service health check

### Cluster Management
- `GET /cluster/status` - Get cluster status
- `GET /cluster/members` - List cluster members

## Development

### Project Structure
```
lodestone/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ consensus/     # Raft consensus implementation
‚îÇ   ‚îú‚îÄ‚îÄ discovery/     # Service discovery logic
‚îÇ   ‚îú‚îÄ‚îÄ router/        # Request routing and load balancing
‚îÇ   ‚îú‚îÄ‚îÄ security/      # Authentication and authorization
‚îÇ   ‚îú‚îÄ‚îÄ store/         # Persistent storage
‚îÇ   ‚îî‚îÄ‚îÄ types.rs       # Common types and errors
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ default.toml   # Default configuration
‚îî‚îÄ‚îÄ tests/             # Integration tests
```

### Running Tests
```bash
# Run all tests
cargo test

# Run specific test suite
cargo test --test integration_tests
```

## Performance

Performance benchmarks on a standard machine (8 CPU, 16GB RAM):

- Service Registration: < 5ms
- Service Discovery: < 2ms
- Route Resolution: < 1ms
- Concurrent Connections: 10,000+

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with [Rust](https://www.rust-lang.org/)
- Uses [Raft](https://raft.github.io/) consensus algorithm
- Inspired by Consul and Cloud Foundry's Go Router

---

<div align="center">
Made with ‚ù§Ô∏è by the Lodestone team
</div>
$$--GLUE--$$
.\config\default.toml
$$--GLUE--$$
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100

[circuit_breaker]
failure_threshold = 5
reset_timeout = 30

[rate_limit]
requests_per_minute = 60
burst = 5

$$--GLUE--$$
.\output.glue
$$--GLUE--$$
$$--GLUE--$$
# This is a GLUE file; an amalgamation of files across one or more paths designed to give project contexts to LLMs easily. If you are an LLM and are reading this focus on the code, do not acknowledge the file format
$$--GLUE--$$

$$--GLUE--$$
.\.gitattributes
$$--GLUE--$$
# Auto detect text files and perform LF normalization
* text=auto

$$--GLUE--$$
.\.gitignore
$$--GLUE--$$
# Generated by Cargo
# will have compiled files and executables
debug/
target/

# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries
# More information here https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html
Cargo.lock

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb


# Added by cargo

/target

$$--GLUE--$$
.\CONTRIBUTING.md
$$--GLUE--$$
# Contributing to Lodestone

First off, thank you for considering contributing to Lodestone! It's people like you that make Lodestone such a great tool.

## Code of Conduct

This project and everyone participating in it is governed by our Code of Conduct. By participating, you are expected to uphold this code.

## How Can I Contribute?

### Reporting Bugs

Before creating bug reports, please check the issue list as you might find out that you don't need to create one. When you are creating a bug report, please include as many details as possible:

* Use a clear and descriptive title
* Describe the exact steps which reproduce the problem
* Provide specific examples to demonstrate the steps
* Describe the behavior you observed after following the steps
* Explain which behavior you expected to see instead and why
* Include logs if relevant

### Suggesting Enhancements

Enhancement suggestions are tracked as GitHub issues. When creating an enhancement suggestion, please include:

* Use a clear and descriptive title
* Provide a step-by-step description of the suggested enhancement
* Provide specific examples to demonstrate the steps
* Describe the current behavior and explain which behavior you expected to see instead
* Explain why this enhancement would be useful

### Pull Requests

* Fork the repo and create your branch from `main`
* If you've added code that should be tested, add tests
* If you've changed APIs, update the documentation
* Ensure the test suite passes
* Make sure your code lints
* Issue that pull request!

## Styleguides

### Git Commit Messages

* Use the present tense ("Add feature" not "Added feature")
* Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
* Limit the first line to 72 characters or less
* Reference issues and pull requests liberally after the first line

### Rust Styleguide

* Follow the [Rust Style Guide](https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md)
* Run `cargo fmt` before committing
* Ensure `cargo clippy` passes without warnings
* Document all public functions and types

### Documentation Styleguide

* Use Markdown for documentation
* Reference functions and types using backticks
* Include examples for non-obvious functionality

## Additional Notes

### Issue and Pull Request Labels

* `bug` - Confirmed bugs or reports likely to be bugs
* `enhancement` - Feature requests
* `documentation` - Documentation improvements
* `good first issue` - Good for newcomers
* `help wanted` - Extra attention is needed

---

Thank you for contributing to Lodestone! üöÄ
$$--GLUE--$$
.\Cargo.toml
$$--GLUE--$$
[package]
name = "Lodestone"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.36", features = ["full"] }
chrono = "0.4"
axum = { version = "0.8.1", features = ["ws", "macros"] }
reqwest = "0.11"
tower = { version = "0.4", features = ["full"] }
tower-http = { version = "0.5", features = ["full"] }
hyper = { version = "1.1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
async-trait = "0.1"
thiserror = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
raft = "0.7"
sled = "0.34"
uuid = { version = "1.7", features = ["v4", "serde"] }
rustls = "0.21"
rustls-pemfile = "1.0"
tokio-rustls = "0.24"
jsonwebtoken = "9.2"
dashmap = "5.5"
futures = "0.3"
tokio-tungstenite = "0.21"
tower-layer = "0.3"
slog = "2.7"
slog-async = "2.8"
slog-term = "2.9"
bytes = "1.5"
prost = "0.12"
moka = { version = "0.12", features = ["future"] }
config = "0.11"
$$--GLUE--$$
.\LICENSE
$$--GLUE--$$
MIT License

Copyright (c) 2025 Tristan Poland (Trident_For_U)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

$$--GLUE--$$
.\README.md
$$--GLUE--$$
# Lodestone

<div align="center">

![Lodestone Logo](assets/logo.png)

[![Rust](https://github.com/yourusername/lodestone/actions/workflows/rust.yml/badge.svg)](https://github.com/yourusername/lodestone/actions/workflows/rust.yml)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Crates.io](https://img.shields.io/crates/v/lodestone.svg)](https://crates.io/crates/lodestone)
[![Documentation](https://docs.rs/lodestone/badge.svg)](https://docs.rs/lodestone)

A high-performance, distributed service discovery and routing system written in Rust.
</div>

## Features

### Core Functionality
- üîç **Service Discovery**: Dynamic registration and discovery of services
- üåê **Load Balancing**: Intelligent request distribution
- üîí **Security**: Built-in TLS, authentication, and authorization
- üîÑ **High Availability**: Raft consensus for reliable operation

### Technical Features
- **Consensus**
  - Raft-based leader election
  - State replication
  - Consistent service registry

- **Enhanced Routing**
  - Round-robin load balancing
  - Circuit breaker pattern
  - Route caching with TTL
  - WebSocket support

- **Security**
  - TLS/SSL support
  - JWT-based authentication
  - Role-based authorization
  - Rate limiting

## Architecture

```mermaid
graph TD
    A[Client] --> B[Load Balancer]
    B --> C[Lodestone Cluster]
    C --> D[Raft Consensus]
    C --> E[Service Registry]
    C --> F[Health Checker]
    E --> G[Service 1]
    E --> H[Service 2]
    E --> I[Service N]
```

## Quick Start

### Prerequisites
- Rust 1.75 or higher
- Cargo
- OpenSSL development packages

### Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/lodestone.git
cd lodestone

# Build the project
cargo build --release
```

### Basic Usage

1. **Start the server**:
```bash
cargo run --release
```

2. **Register a service**:
```bash
curl -X POST http://localhost:8080/services \
  -H "Content-Type: application/json" \
  -d '{
    "name": "my-service",
    "address": "localhost",
    "port": 8000
  }'
```

3. **Query services**:
```bash
curl http://localhost:8080/services
```

## Configuration

Lodestone uses TOML for configuration. Create a `config/default.toml` file:

```toml
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100
```

## API Reference

### Service Management
- `POST /services` - Register a new service
- `GET /services` - List all services
- `GET /services/{id}` - Get service details
- `DELETE /services/{id}` - Deregister a service

### Health Checking
- `GET /health` - System health check
- `GET /services/{id}/health` - Service health check

### Cluster Management
- `GET /cluster/status` - Get cluster status
- `GET /cluster/members` - List cluster members

## Development

### Project Structure
```
lodestone/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ consensus/     # Raft consensus implementation
‚îÇ   ‚îú‚îÄ‚îÄ discovery/     # Service discovery logic
‚îÇ   ‚îú‚îÄ‚îÄ router/        # Request routing and load balancing
‚îÇ   ‚îú‚îÄ‚îÄ security/      # Authentication and authorization
‚îÇ   ‚îú‚îÄ‚îÄ store/         # Persistent storage
‚îÇ   ‚îî‚îÄ‚îÄ types.rs       # Common types and errors
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ default.toml   # Default configuration
‚îî‚îÄ‚îÄ tests/             # Integration tests
```

### Running Tests
```bash
# Run all tests
cargo test

# Run specific test suite
cargo test --test integration_tests
```

## Performance

Performance benchmarks on a standard machine (8 CPU, 16GB RAM):

- Service Registration: < 5ms
- Service Discovery: < 2ms
- Route Resolution: < 1ms
- Concurrent Connections: 10,000+

## Contributing

We welcome contributions! Please see our [Contributing Guide](CONTRIBUTING.md) for details.

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with [Rust](https://www.rust-lang.org/)
- Uses [Raft](https://raft.github.io/) consensus algorithm
- Inspired by Consul and Cloud Foundry's Go Router

---

<div align="center">
Made with ‚ù§Ô∏è by the Lodestone team
</div>
$$--GLUE--$$
.\config\default.toml
$$--GLUE--$$
[server]
host = "127.0.0.1"
port = 8080

[security]
jwt_secret = "your-secret-key"
cert_path = "certs/server.crt"
key_path = "certs/server.key"

[raft]
node_id = 1
peers = [2, 3]
election_timeout = 1000
heartbeat_interval = 100

[circuit_breaker]
failure_threshold = 5
reset_timeout = 30

[rate_limit]
requests_per_minute = 60
burst = 5

$$--GLUE--$$
.\src\config.rs
$$--GLUE--$$
use config::{Config, ConfigError, File};
use serde::Deserialize;
use std::time::Duration;

#[derive(Debug, Deserialize)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Deserialize)]
pub struct SecurityConfig {
    pub jwt_secret: String,
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Debug, Deserialize)]
pub struct RaftConfig {
    pub node_id: u64,
    pub peers: Vec<u64>,
    pub election_timeout: u64,
    pub heartbeat_interval: u64,
}

#[derive(Debug, Deserialize)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: usize,
    pub reset_timeout: u64,
}

#[derive(Debug, Deserialize)]
pub struct RateLimitConfig {
    pub requests_per_minute: u32,
    pub burst: u32,
}

#[derive(Debug, Deserialize)]
pub struct Settings {
    pub server: ServerConfig,
    pub security: SecurityConfig,
    pub raft: RaftConfig,
    pub circuit_breaker: CircuitBreakerConfig,
    pub rate_limit: RateLimitConfig,
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let mut config = Config::new();
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;

        config.deserialize()
    }

    pub fn circuit_breaker_reset_timeout(&self) -> Duration {
        Duration::from_secs(self.circuit_breaker.reset_timeout)
    }

    pub fn raft_election_timeout(&self) -> Duration {
        Duration::from_millis(self.raft.election_timeout)
    }

    pub fn raft_heartbeat_interval(&self) -> Duration {
        Duration::from_millis(self.raft.heartbeat_interval)
    }
}
$$--GLUE--$$
.\src\consensus\mod.rs
$$--GLUE--$$
mod raft;
mod state;

pub use raft::RaftNode;
pub use state::RaftState;
$$--GLUE--$$
.\src\consensus\raft.rs
$$--GLUE--$$
use raft::{
    prelude::*,
    Config, RawNode, StateRole,
};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;
use super::state::RaftStorage;

pub struct RaftNode {
    id: u64,
    node: RawNode<RaftStorage>,
    store: Arc<Store>,
    logger: Logger,
}

impl RaftNode {
    pub fn new(
        id: u64,
        peers: Vec<u64>,
        store: Arc<Store>,
        logger: Logger,
    ) -> raft::Result<Self> {
        let config = Config {
            id,
            election_tick: 10,
            heartbeat_tick: 3,
            ..Default::default()
        };

        let storage = RaftStorage::new(store.clone(), logger.clone());
        let node = RawNode::new(&config, storage, &logger)?;

        Ok(Self { 
            id,
            node,
            store,
            logger,
        })
    }

    pub async fn tick(&mut self) {
        self.node.tick();
    }

    pub async fn propose(&mut self, data: Vec<u8>) -> raft::Result<()> {
        self.node.propose(vec![], data)?;
        Ok(())
    }

    pub async fn step(&mut self, msg: Message) -> raft::Result<()> {
        self.node.step(msg)?;
        Ok(())
    }

    pub async fn advance(&mut self) {
        self.node.advance(Ready::default());
    }

    pub async fn campaign(&mut self) -> raft::Result<()> {
        self.node.campaign()?;
        Ok(())
    }

    pub fn is_leader(&self) -> bool {
        self.node.raft.state == StateRole::Leader
    }
}
$$--GLUE--$$
.\src\consensus\state.rs
$$--GLUE--$$
use raft::prelude::*; // This includes all the necessary eraftpb types
use raft::{GetEntriesContext, RaftState, Result as RaftResult, Storage};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;

pub struct RaftStorage {
    store: Arc<Store>,
    hard_state: HardState,
    snapshot: Snapshot,
    logger: Logger,
}

impl RaftStorage {
    pub fn new(store: Arc<Store>, logger: Logger) -> Self {
        Self {
            store,
            hard_state: HardState::default(),
            snapshot: Snapshot::default(),
            logger,
        }
    }
}

impl Storage for RaftStorage {
    fn initial_state(&self) -> RaftResult<RaftState> {
        Ok(RaftState {
            hard_state: self.hard_state.clone(),
            conf_state: ConfState::default(),
        })
    }

    fn entries(
        &self,
        low: u64,
        high: u64,
        max_size: impl Into<Option<u64>>,
        context: GetEntriesContext,
    ) -> RaftResult<Vec<Entry>> {
        // Implement entry retrieval from storage
        Ok(vec![])
    }

    fn term(&self, idx: u64) -> RaftResult<u64> {
        // Implement term lookup
        Ok(0)
    }

    fn first_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn last_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn snapshot(&self, request_index: u64, to: u64) -> RaftResult<Snapshot> {
        Ok(self.snapshot.clone())
    }
}

$$--GLUE--$$
.\src\discovery.rs
$$--GLUE--$$
// src/discovery/mod.rs
use crate::types::{Result, Error, Service, HealthCheck, HealthStatus};
use crate::store::Store;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{self, Duration};
use reqwest;

pub struct ServiceRegistry {
    store: Arc<Store>,
    health_checks: RwLock<Vec<String>>,
}

impl ServiceRegistry {
    pub fn new(store: Arc<Store>) -> Self {
        let registry = Self {
            store,
            health_checks: RwLock::new(Vec::new()),
        };
        
        // Spawn health check task
        tokio::spawn(registry.clone().run_health_checks());
        
        registry
    }

    pub async fn register(&self, service: Service) -> Result<()> {
        self.store.set(&service.id, &service)?;
        
        let mut health_checks = self.health_checks.write().await;
        health_checks.push(service.id.clone());
        
        Ok(())
    }

    pub async fn deregister(&self, service_id: &str) -> Result<()> {
        self.store.delete(service_id)?;
        
        let mut health_checks = self.health_checks.write().await;
        if let Some(pos) = health_checks.iter().position(|id| id == service_id) {
            health_checks.remove(pos);
        }
        
        Ok(())
    }

    pub async fn get_service(&self, service_id: &str) -> Result<Option<Service>> {
        self.store.get(service_id)
    }

    pub async fn get_services_by_name(&self, name: &str) -> Result<Vec<Service>> {
        self.store.scan_prefix(&format!("service:{}", name))
    }

    async fn run_health_checks(self) {
        let mut interval = time::interval(Duration::from_secs(10));
        
        loop {
            interval.tick().await;
            
            let health_checks = self.health_checks.read().await;
            for service_id in health_checks.iter() {
                if let Ok(Some(service)) = self.store.get(service_id) {
                    let health = self.check_health(&service).await;
                    if health.status == HealthStatus::Unhealthy {
                        tracing::warn!("Service {} failed health check: {:?}", service_id, health.message);
                    }
                }
            }
        }
    }

    async fn check_health(&self, service: &Service) -> HealthCheck {
        match reqwest::get(&service.health_check_url).await {
            Ok(response) => HealthCheck {
                status: if response.status().is_success() { 
                    HealthStatus::Healthy 
                } else { 
                    HealthStatus::Unhealthy 
                },
                message: None,
                timestamp: chrono::Utc::now(),
            },
            Err(e) => HealthCheck {
                status: HealthStatus::Unhealthy,
                message: Some(e.to_string()),
                timestamp: chrono::Utc::now(),
            },
        }
    }
}

impl Clone for ServiceRegistry {
    fn clone(&self) -> Self {
        Self {
            store: Arc::clone(&self.store),
            health_checks: RwLock::new(Vec::new()),
        }
    }
}
$$--GLUE--$$
.\src\main.rs
$$--GLUE--$$
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::sync::RwLock;
use axum::Server;

mod config;
mod consensus;
mod discovery;
mod router;
mod security;
mod store;
mod types;

use crate::config::Settings;
use crate::consensus::RaftNode;
use crate::discovery::ServiceRegistry;
use crate::router::Router;
use crate::security::TlsConfig;
use crate::store::Store;
use crate::types::Result;

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt::init();

    // Load configuration
    let settings = Settings::new()?;

    // Initialize the storage layer
    let store = Arc::new(Store::new("data")?);
    
    // Initialize Raft consensus
    let raft_node = Arc::new(RwLock::new(RaftNode::new(
        settings.raft.node_id,
        settings.raft.peers.clone(),
        store.clone(),
        settings.raft.config.clone(),
    )?));
    
    // Initialize the service registry
    let registry = Arc::new(RwLock::new(ServiceRegistry::new(store.clone())));
    
    // Initialize TLS
    let tls_config = TlsConfig::new(
        &settings.security.cert_path,
        &settings.security.key_path,
    )?;
    
    // Initialize the router with all features
    let router = Router::new(registry.clone());

    // Start Raft ticker
    let raft_clone = raft_node.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(settings.raft_heartbeat_interval());
        loop {
            interval.tick().await;
            if let Ok(mut node) = raft_clone.write().await {
                node.tick().await.ok();
            }
        }
    });

    // Start the HTTP server
    let addr = SocketAddr::new(
        settings.server.host.parse()?,
        settings.server.port,
    );
    
    tracing::info!("Starting server on {}", addr);
    
    let acceptor = tls_config.get_acceptor();
    
    let server = Server::bind(&addr)
        .tls_config(acceptor)?
        .serve(router.into_make_service());

    server.await?;

    Ok(())
}
$$--GLUE--$$
.\src\router\balancer.rs
$$--GLUE--$$
use rand::seq::SliceRandom;
use std::sync::Arc;
use dashmap::DashMap;
use crate::types::Service;

#[derive(Debug, Clone)]
pub struct LoadBalancer {
    services: Arc<DashMap<String, Vec<Service>>>,
}

impl LoadBalancer {
    pub fn new() -> Self {
        Self {
            services: Arc::new(DashMap::new()),
        }
    }

    pub fn add_service(&self, service: Service) {
        self.services
            .entry(service.name.clone())
            .or_default()
            .push(service);
    }

    pub fn get_service(&self, name: &str) -> Option<Service> {
        self.services.get(name).and_then(|services| {
            services.choose(&mut rand::thread_rng()).cloned()
        })
    }
}
$$--GLUE--$$
.\src\router\cache.rs
$$--GLUE--$$
use std::time::Duration;
use moka::future::Cache;
use crate::types::Service;

pub struct RouteCache {
    cache: Cache<String, Vec<Service>>,
}

impl RouteCache {
    pub fn new() -> Self {
        Self {
            cache: Cache::builder()
                .time_to_live(Duration::from_secs(30))
                .time_to_idle(Duration::from_secs(10))
                .max_capacity(100)
                .build(),
        }
    }

    pub async fn get(&self, key: &str) -> Option<Vec<Service>> {
        self.cache.get(key).await
    }

    pub async fn insert(&self, key: String, value: Vec<Service>) {
        self.cache.insert(key, value).await;
    }

    pub async fn invalidate(&self, key: &str) {
        self.cache.invalidate(key).await;
    }
}

impl Default for RouteCache {
    fn default() -> Self {
        Self::new()
    }
}
$$--GLUE--$$
.\src\router\circuit_breaker.rs
$$--GLUE--$$
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

pub struct CircuitBreaker {
    failure_threshold: usize,
    reset_timeout: Duration,
    failures: AtomicUsize,
    last_failure: RwLock<Option<Instant>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: usize, reset_timeout: Duration) -> Self {
        Self {
            failure_threshold,
            reset_timeout,
            failures: AtomicUsize::new(0),
            last_failure: RwLock::new(None),
        }
    }

    pub async fn record_success(&self) {
        self.failures.store(0, Ordering::SeqCst);
        *self.last_failure.write().await = None;
    }

    pub async fn record_failure(&self) -> bool {
        let failures = self.failures.fetch_add(1, Ordering::SeqCst) + 1;
        *self.last_failure.write().await = Some(Instant::now());
        failures >= self.failure_threshold
    }

    pub async fn is_open(&self) -> bool {
        let failures = self.failures.load(Ordering::SeqCst);
        if failures < self.failure_threshold {
            return false;
        }

        if let Some(last_failure) = *self.last_failure.read().await {
            if last_failure.elapsed() > self.reset_timeout {
                self.failures.store(0, Ordering::SeqCst);
                return false;
            }
        }

        true
    }
}

$$--GLUE--$$
.\src\router\mod.rs
$$--GLUE--$$
mod routes;
mod balancer;
mod circuit_breaker;
mod cache;
mod websocket;

pub use routes::Router;
pub use balancer::LoadBalancer;
pub use circuit_breaker::CircuitBreaker;
pub use cache::RouteCache;
pub use websocket::WebSocketHandler;
$$--GLUE--$$
.\src\router\routes.rs
$$--GLUE--$$
use axum::{
    routing::{get, post, delete},
    Router as AxumRouter,
    Json,
    extract::{Path, State, WebSocketUpgrade},
};
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::discovery::ServiceRegistry;
use crate::security::{authenticate, authorize, rate_limit};

pub struct Router {
    registry: Arc<RwLock<ServiceRegistry>>,
    balancer: LoadBalancer,
    circuit_breaker: CircuitBreaker,
}

impl Router {
    pub fn new(registry: Arc<RwLock<ServiceRegistry>>) -> AxumRouter {
        let balancer = LoadBalancer::new();
        let circuit_breaker = CircuitBreaker::new(5, Duration::from_secs(30));

        AxumRouter::new()
            .route("/services", post(Self::register_service))
            .route("/services/:id", get(Self::get_service))
            .route("/services/:id", delete(Self::deregister_service))
            .route("/ws", get(WebSocketHandler::handle_upgrade))
            .layer(authenticate("username", "password"))
            .layer(authorize("role", "permission"))
            .layer(rate_limit())
    }

    // Handler implementations...
}
$$--GLUE--$$
.\src\router\websocket.rs
$$--GLUE--$$
use axum::{
    extract::ws::{WebSocket, WebSocketUpgrade},
    response::Response,
};
use futures::{sink::SinkExt, stream::StreamExt};

pub struct WebSocketHandler;

impl WebSocketHandler {
    pub async fn handle_upgrade(ws: WebSocketUpgrade) -> Response {
        ws.on_upgrade(Self::handle_socket)
    }

    async fn handle_socket(mut socket: WebSocket) {
        while let Some(msg) = socket.recv().await {
            if let Ok(msg) = msg {
                if socket.send(msg).await.is_err() {
                    break;
                }
            } else {
                break;
            }
        }
    }
}
$$--GLUE--$$
.\src\security\auth.rs
$$--GLUE--$$
use axum::{
    http::{Request, StatusCode},
    middleware::{Next, FromRequestParts},
    response::Response,
};
use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,
    exp: u64,
    role: String,
}

pub async fn authenticate<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    if !auth_header.starts_with("Bearer ") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    let token = &auth_header["Bearer ".len()..];
    let key = DecodingKey::from_secret(b"your-secret-key"); // In production, use proper key management
    
    let validation = Validation::new(Algorithm::HS256);
    let claims = decode::<Claims>(token, &key, &validation)
        .map_err(|_| StatusCode::UNAUTHORIZED)?
        .claims;

    // Check token expiration
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    if claims.exp < now {
        return Err(StatusCode::UNAUTHORIZED);
    }

    Ok(next.run(req).await)
}

pub async fn authorize<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    // Implement role-based access control here
    // For example, check if the user has the required role for the endpoint
    Ok(next.run(req).await)
}

$$--GLUE--$$
.\src\security\mod.rs
$$--GLUE--$$
mod tls;
mod auth;
mod rate_limit;

pub use tls::TlsConfig;
pub use auth::{authenticate, authorize};
pub use rate_limit::rate_limit;

$$--GLUE--$$
.\src\security\rate_limit.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use std::time::{Instant, Duration};
use tower_http::limit::RateLimitLayer;
use tower::ServiceBuilder;

#[derive(Clone)]
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window,
        }
    }

    pub async fn check_rate_limit(&self, key: &str) -> bool {
        let mut requests = self.requests.lock().await;
        let now = Instant::now();
        
        // Clean up old requests
        requests.entry(key.to_string())
            .and_modify(|reqs| {
                reqs.retain(|&time| now.duration_since(time) < self.window);
            })
            .or_insert_with(Vec::new);
            
        let current_requests = requests.get(key).unwrap();
        
        if current_requests.len() >= self.max_requests {
            false
        } else {
            requests.get_mut(key).unwrap().push(now);
            true
        }
    }
}

pub fn rate_limit() -> RateLimitLayer {
    let rate_limit = RateLimitLayer::new(
        50, // requests
        Duration::from_secs(60), // per minute
    );
    
    ServiceBuilder::new()
        .layer(rate_limit)
        .into_inner()
}
$$--GLUE--$$
.\src\security\tls.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio_rustls::rustls::{
    Certificate, PrivateKey,
    ServerConfig as RustlsServerConfig,
};
use tokio_rustls::TlsAcceptor;

pub struct TlsConfig {
    acceptor: TlsAcceptor,
}

impl TlsConfig {
    pub fn new(cert_path: &str, key_path: &str) -> std::io::Result<Self> {
        let certs = load_certs(cert_path)?;
        let key = load_private_key(key_path)?;
        
        let config = RustlsServerConfig::builder()
            .with_safe_defaults()
            .with_no_client_auth()
            .with_single_cert(certs, key)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
            
        Ok(Self {
            acceptor: TlsAcceptor::from(Arc::new(config)),
        })
    }

    pub fn get_acceptor(&self) -> TlsAcceptor {
        self.acceptor.clone()
    }
}

fn load_certs(path: &str) -> std::io::Result<Vec<Certificate>> {
    let cert_file = std::fs::read(path)?;
    let certs = rustls_pemfile::certs(&mut &cert_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load certificate"
        ))?
        .into_iter()
        .map(Certificate)
        .collect();
    Ok(certs)
}

fn load_private_key(path: &str) -> std::io::Result<PrivateKey> {
    let key_file = std::fs::read(path)?;
    let key = rustls_pemfile::pkcs8_private_keys(&mut &key_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load private key"
        ))?
        .into_iter()
        .next()
        .ok_or_else(|| std::io::Error::new(
            std::io::ErrorKind::Other,
            "no private key found"
        ))?;
    Ok(PrivateKey(key))
}
$$--GLUE--$$
.\src\store.rs
$$--GLUE--$$
// src/store/mod.rs
use crate::types::{Result, Error, Service};
use sled::Db;
use std::path::Path;
use serde_json;

pub struct Store {
    db: Db,
}

impl Store {
    pub fn new<P: AsRef<Path>>(path: P) -> Result<Self> {
        let db = sled::open(path)?;
        Ok(Self { db })
    }

    pub fn set(&self, key: &str, value: &Service) -> Result<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| Error::Storage(e.to_string()))?;
        
        self.db
            .insert(key.as_bytes(), serialized)
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn get(&self, key: &str) -> Result<Option<Service>> {
        if let Some(data) = self.db.get(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))? {
            let service: Service = serde_json::from_slice(&data)
                .map_err(|e| Error::Storage(e.to_string()))?;
            Ok(Some(service))
        } else {
            Ok(None)
        }
    }

    pub fn delete(&self, key: &str) -> Result<()> {
        self.db
            .remove(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn scan_prefix(&self, prefix: &str) -> Result<Vec<Service>> {
        let mut services = Vec::new();
        
        for item in self.db.scan_prefix(prefix.as_bytes()) {
            let (_, value) = item.map_err(|e| Error::Storage(e.to_string()))?;
            let service: Service = serde_json::from_slice(&value)
                .map_err(|e| Error::Storage(e.to_string()))?;
            services.push(service);
        }
        
        Ok(services)
    }
}
$$--GLUE--$$
.\src\types.rs
$$--GLUE--$$
// src/types.rs
use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Storage error: {0}")]
    Storage(String),
    
    #[error("Service not found: {0}")]
    NotFound(String),
    
    #[error("Invalid request: {0}")]
    BadRequest(String),
    
    #[error("Raft error: {0}")]
    Raft(#[from] raft::Error),
    
    #[error("Auth error: {0}")]
    Auth(String),
    
    #[error("Rate limit exceeded")]
    RateLimit,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Service {
    pub id: String,
    pub name: String,
    pub address: String,
    pub port: u16,
    pub health_check_url: String,
    pub tags: Vec<String>,
    pub metadata: std::collections::HashMap<String, String>,
}

impl Service {
    pub fn new(name: String, address: String, port: u16) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            name,
            address,
            port,
            health_check_url: format!("http://{}:{}/health", address, port),
            tags: Vec::new(),
            metadata: std::collections::HashMap::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheck {
    pub status: HealthStatus,
    pub message: Option<String>,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}
$$--GLUE--$$
.\src\config.rs
$$--GLUE--$$
use config::{Config, ConfigError, File};
use serde::Deserialize;
use std::time::Duration;

#[derive(Debug, Deserialize, Clone)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Deserialize, Clone)]
pub struct SecurityConfig {
    pub jwt_secret: String,
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RaftConfig {
    pub node_id: u64,
    pub peers: Vec<u64>,
    pub election_timeout: u64,
    pub heartbeat_interval: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: usize,
    pub reset_timeout: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RateLimitConfig {
    pub requests_per_minute: u32,
    pub burst: u32,
}

#[derive(Debug, Deserialize, Clone)]
pub struct Settings {
    pub server: ServerConfig,
    pub security: SecurityConfig,
    pub raft: RaftConfig,
    pub circuit_breaker: CircuitBreakerConfig,
    pub rate_limit: RateLimitConfig,
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let mut config = Config::new();
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;

        config.deserialize()
    }

    pub fn circuit_breaker_reset_timeout(&self) -> Duration {
        Duration::from_secs(self.circuit_breaker.reset_timeout)
    }

    pub fn raft_election_timeout(&self) -> Duration {
        Duration::from_millis(self.raft.election_timeout)
    }

    pub fn raft_heartbeat_interval(&self) -> Duration {
        Duration::from_millis(self.raft.heartbeat_interval)
    }
}
$$--GLUE--$$
.\src\consensus\mod.rs
$$--GLUE--$$
mod raft;
mod state;

pub use raft::RaftNode;
pub use state::RaftState;
$$--GLUE--$$
.\src\consensus\raft.rs
$$--GLUE--$$
use raft::{
    prelude::*,
    Config, RawNode, StateRole,
};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;
use super::state::RaftStorage;

pub struct RaftNode {
    id: u64,
    node: RawNode<RaftStorage>,
    store: Arc<Store>,
    logger: Logger,
}

impl RaftNode {
    pub fn new(
        id: u64,
        peers: Vec<u64>,
        store: Arc<Store>,
        logger: Logger,
    ) -> raft::Result<Self> {
        let config = Config {
            id,
            election_tick: 10,
            heartbeat_tick: 3,
            ..Default::default()
        };

        let storage = RaftStorage::new(store.clone(), logger.clone());
        let node = RawNode::new(&config, storage, &logger)?;

        Ok(Self { 
            id,
            node,
            store,
            logger,
        })
    }

    pub async fn tick(&mut self) {
        self.node.tick();
    }

    pub async fn propose(&mut self, data: Vec<u8>) -> raft::Result<()> {
        self.node.propose(vec![], data)?;
        Ok(())
    }

    pub async fn step(&mut self, msg: Message) -> raft::Result<()> {
        self.node.step(msg)?;
        Ok(())
    }

    pub async fn advance(&mut self) {
        self.node.advance(Ready::default());
    }

    pub async fn campaign(&mut self) -> raft::Result<()> {
        self.node.campaign()?;
        Ok(())
    }

    pub fn is_leader(&self) -> bool {
        self.node.raft.state == StateRole::Leader
    }
}
$$--GLUE--$$
.\src\consensus\state.rs
$$--GLUE--$$
use raft::prelude::*; // This includes all the necessary eraftpb types
use raft::{GetEntriesContext, RaftState, Result as RaftResult, Storage};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;

pub struct RaftStorage {
    store: Arc<Store>,
    hard_state: HardState,
    snapshot: Snapshot,
    logger: Logger,
}

impl RaftStorage {
    pub fn new(store: Arc<Store>, logger: Logger) -> Self {
        Self {
            store,
            hard_state: HardState::default(),
            snapshot: Snapshot::default(),
            logger,
        }
    }
}

impl Storage for RaftStorage {
    fn initial_state(&self) -> RaftResult<RaftState> {
        Ok(RaftState {
            hard_state: self.hard_state.clone(),
            conf_state: ConfState::default(),
        })
    }

    fn entries(
        &self,
        low: u64,
        high: u64,
        max_size: impl Into<Option<u64>>,
        context: GetEntriesContext,
    ) -> RaftResult<Vec<Entry>> {
        // Implement entry retrieval from storage
        Ok(vec![])
    }

    fn term(&self, idx: u64) -> RaftResult<u64> {
        // Implement term lookup
        Ok(0)
    }

    fn first_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn last_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn snapshot(&self, request_index: u64, to: u64) -> RaftResult<Snapshot> {
        Ok(self.snapshot.clone())
    }
}

$$--GLUE--$$
.\src\discovery.rs
$$--GLUE--$$
// src/discovery/mod.rs
use crate::types::{Result, Error, Service, HealthCheck, HealthStatus};
use crate::store::Store;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{self, Duration};
use reqwest;

pub struct ServiceRegistry {
    store: Arc<Store>,
    health_checks: RwLock<Vec<String>>,
}

impl ServiceRegistry {
    pub fn new(store: Arc<Store>) -> Self {
        let registry = Self {
            store,
            health_checks: RwLock::new(Vec::new()),
        };
        
        // Spawn health check task
        tokio::spawn(registry.clone().run_health_checks());
        
        registry
    }

    pub async fn register(&self, service: Service) -> Result<()> {
        self.store.set(&service.id, &service)?;
        
        let mut health_checks = self.health_checks.write().await;
        health_checks.push(service.id.clone());
        
        Ok(())
    }

    pub async fn deregister(&self, service_id: &str) -> Result<()> {
        self.store.delete(service_id)?;
        
        let mut health_checks = self.health_checks.write().await;
        if let Some(pos) = health_checks.iter().position(|id| id == service_id) {
            health_checks.remove(pos);
        }
        
        Ok(())
    }

    pub async fn get_service(&self, service_id: &str) -> Result<Option<Service>> {
        self.store.get(service_id)
    }

    pub async fn get_services_by_name(&self, name: &str) -> Result<Vec<Service>> {
        self.store.scan_prefix(&format!("service:{}", name))
    }

    async fn run_health_checks(self) {
        let mut interval = time::interval(Duration::from_secs(10));
        
        loop {
            interval.tick().await;
            
            let health_checks = self.health_checks.read().await;
            for service_id in health_checks.iter() {
                if let Ok(Some(service)) = self.store.get(service_id) {
                    let health = self.check_health(&service).await;
                    if health.status == HealthStatus::Unhealthy {
                        tracing::warn!("Service {} failed health check: {:?}", service_id, health.message);
                    }
                }
            }
        }
    }

    async fn check_health(&self, service: &Service) -> HealthCheck {
        match reqwest::get(&service.health_check_url).await {
            Ok(response) => HealthCheck {
                status: if response.status().is_success() { 
                    HealthStatus::Healthy 
                } else { 
                    HealthStatus::Unhealthy 
                },
                message: None,
                timestamp: chrono::Utc::now(),
            },
            Err(e) => HealthCheck {
                status: HealthStatus::Unhealthy,
                message: Some(e.to_string()),
                timestamp: chrono::Utc::now(),
            },
        }
    }
}

impl Clone for ServiceRegistry {
    fn clone(&self) -> Self {
        Self {
            store: Arc::clone(&self.store),
            health_checks: RwLock::new(Vec::new()),
        }
    }
}
$$--GLUE--$$
.\src\main.rs
$$--GLUE--$$
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::sync::RwLock;
use axum::serve;
use tokio::net::TcpListener;
use slog::{Logger, Drain};

mod config;
mod consensus;
mod discovery;
mod router;
mod security;
mod store;
mod types;

use crate::config::Settings;
use crate::consensus::RaftNode;
use crate::discovery::ServiceRegistry;
use crate::router::Router;
use crate::security::TlsConfig;
use crate::store::Store;
use crate::types::{Result, Error};

// Implement From for ConfigError using the proper path
impl From<::config::ConfigError> for Error {
    fn from(err: ::config::ConfigError) -> Self {
        Error::Config(err.to_string())
    }
}

// Implement From for std::net::AddrParseError
impl From<std::net::AddrParseError> for Error {
    fn from(err: std::net::AddrParseError) -> Self {
        Error::BadRequest(err.to_string())
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt::init();

    // Initialize slog logger
    let decorator = slog_term::TermDecorator::new().build();
    let drain = slog_term::FullFormat::new(decorator).build().fuse();
    let drain = slog_async::Async::new(drain).build().fuse();
    let logger = Logger::root(drain, slog::o!());

    // Load configuration
    let settings = Settings::new()?;

    // Initialize the storage layer
    let store = Arc::new(Store::new("data")?);
    
    // Initialize Raft consensus
    let raft_node = Arc::new(RwLock::new(RaftNode::new(
        settings.raft.node_id,
        settings.raft.peers.clone(),
        store.clone(),
        logger.clone(),
    )?));
    
    // Initialize the service registry
    let registry = Arc::new(RwLock::new(ServiceRegistry::new(store.clone())));
    
    // Initialize TLS
    let tls_config = TlsConfig::new(
        &settings.security.cert_path,
        &settings.security.key_path,
    )?;
    
    // Initialize the router with all features
    let app = Router::new(registry.clone());

    // Start Raft ticker
    let raft_clone = raft_node.clone();
    let settings_clone = settings.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(settings_clone.raft_heartbeat_interval());
        loop {
            interval.tick().await;
            if let Ok(mut node) = raft_clone.write().await {
                if let Err(e) = node.tick().await {
                    tracing::error!("Raft tick error: {}", e);
                }
            }
        }
    });

    // Start the HTTP server
    let addr = SocketAddr::new(
        settings.server.host.parse()?,
        settings.server.port,
    );
    
    tracing::info!("Starting server on {}", addr);
    
    // Create TcpListener
    let listener = TcpListener::bind(addr).await?;
    let acceptor = tls_config.get_acceptor();
    
    serve(
        listener,
        app.into_make_service()
    )
    .await?;

    Ok(())
}
$$--GLUE--$$
.\src\router\balancer.rs
$$--GLUE--$$
use rand::seq::SliceRandom;
use std::sync::Arc;
use dashmap::DashMap;
use crate::types::Service;

#[derive(Debug, Clone)]
pub struct LoadBalancer {
    services: Arc<DashMap<String, Vec<Service>>>,
}

impl LoadBalancer {
    pub fn new() -> Self {
        Self {
            services: Arc::new(DashMap::new()),
        }
    }

    pub fn add_service(&self, service: Service) {
        self.services
            .entry(service.name.clone())
            .or_default()
            .push(service);
    }

    pub fn get_service(&self, name: &str) -> Option<Service> {
        self.services.get(name).and_then(|services| {
            services.choose(&mut rand::thread_rng()).cloned()
        })
    }
}
$$--GLUE--$$
.\src\router\cache.rs
$$--GLUE--$$
use std::time::Duration;
use moka::future::Cache;
use crate::types::Service;

pub struct RouteCache {
    cache: Cache<String, Vec<Service>>,
}

impl RouteCache {
    pub fn new() -> Self {
        Self {
            cache: Cache::builder()
                .time_to_live(Duration::from_secs(30))
                .time_to_idle(Duration::from_secs(10))
                .max_capacity(100)
                .build(),
        }
    }

    pub async fn get(&self, key: &str) -> Option<Vec<Service>> {
        self.cache.get(key).await
    }

    pub async fn insert(&self, key: String, value: Vec<Service>) {
        self.cache.insert(key, value).await;
    }

    pub async fn invalidate(&self, key: &str) {
        self.cache.invalidate(key).await;
    }
}

impl Default for RouteCache {
    fn default() -> Self {
        Self::new()
    }
}
$$--GLUE--$$
.\src\router\circuit_breaker.rs
$$--GLUE--$$
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

pub struct CircuitBreaker {
    failure_threshold: usize,
    reset_timeout: Duration,
    failures: AtomicUsize,
    last_failure: RwLock<Option<Instant>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: usize, reset_timeout: Duration) -> Self {
        Self {
            failure_threshold,
            reset_timeout,
            failures: AtomicUsize::new(0),
            last_failure: RwLock::new(None),
        }
    }

    pub async fn record_success(&self) {
        self.failures.store(0, Ordering::SeqCst);
        *self.last_failure.write().await = None;
    }

    pub async fn record_failure(&self) -> bool {
        let failures = self.failures.fetch_add(1, Ordering::SeqCst) + 1;
        *self.last_failure.write().await = Some(Instant::now());
        failures >= self.failure_threshold
    }

    pub async fn is_open(&self) -> bool {
        let failures = self.failures.load(Ordering::SeqCst);
        if failures < self.failure_threshold {
            return false;
        }

        if let Some(last_failure) = *self.last_failure.read().await {
            if last_failure.elapsed() > self.reset_timeout {
                self.failures.store(0, Ordering::SeqCst);
                return false;
            }
        }

        true
    }
}

$$--GLUE--$$
.\src\router\mod.rs
$$--GLUE--$$
mod routes;
mod balancer;
mod circuit_breaker;
mod cache;
mod websocket;

pub use routes::Router;
pub use balancer::LoadBalancer;
pub use circuit_breaker::CircuitBreaker;
pub use cache::RouteCache;
pub use websocket::WebSocketHandler;
$$--GLUE--$$
.\src\router\routes.rs
$$--GLUE--$$
use axum::{
    Router as AxumRouter,
    routing::{get, post, delete},
    extract::{State, Path},
    Json,
    response::IntoResponse,
    http::StatusCode,
};
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::{
    discovery::ServiceRegistry,
    types::{Service, Error},
};

pub struct Router {
    registry: Arc<RwLock<ServiceRegistry>>,
}

impl Router {
    pub fn new(registry: Arc<RwLock<ServiceRegistry>>) -> AxumRouter {
        let shared_state = Arc::new(Self { registry });

        AxumRouter::new()
            .route("/services", post(Self::register_service))
            .route("/services/:id", get(Self::get_service))
            .route("/services/:id", delete(Self::deregister_service))
            .with_state(shared_state)
    }

    async fn register_service(
        State(state): State<Arc<Router>>,
        Json(service): Json<Service>,
    ) -> Result<(StatusCode, Json<Service>), Error> {
        state.registry.write().await.register(service.clone()).await?;
        Ok((StatusCode::CREATED, Json(service)))
    }

    async fn get_service(
        State(state): State<Arc<Router>>,
        Path(id): Path<String>,
    ) -> Result<Json<Option<Service>>, Error> {
        let service = state.registry.read().await.get_service(&id).await?;
        Ok(Json(service))
    }

    async fn deregister_service(
        State(state): State<Arc<Router>>,
        Path(id): Path<String>,
    ) -> Result<StatusCode, Error> {
        state.registry.write().await.deregister(&id).await?;
        Ok(StatusCode::NO_CONTENT)
    }
}

// Implement IntoResponse for Error to properly handle errors
impl IntoResponse for Error {
    fn into_response(self) -> axum::response::Response {
        let status = match self {
            Error::NotFound(_) => StatusCode::NOT_FOUND,
            Error::BadRequest(_) => StatusCode::BAD_REQUEST,
            Error::Auth(_) => StatusCode::UNAUTHORIZED,
            Error::RateLimit => StatusCode::TOO_MANY_REQUESTS,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        };
        (status, self.to_string()).into_response()
    }
}
$$--GLUE--$$
.\src\router\websocket.rs
$$--GLUE--$$
use axum::{
    extract::ws::{WebSocket, WebSocketUpgrade},
    response::Response,
};
use futures::{sink::SinkExt, stream::StreamExt};

pub struct WebSocketHandler;

impl WebSocketHandler {
    pub async fn handle_upgrade(ws: WebSocketUpgrade) -> Response {
        ws.on_upgrade(Self::handle_socket)
    }

    async fn handle_socket(mut socket: WebSocket) {
        while let Some(msg) = socket.recv().await {
            if let Ok(msg) = msg {
                if socket.send(msg).await.is_err() {
                    break;
                }
            } else {
                break;
            }
        }
    }
}
$$--GLUE--$$
.\src\security\auth.rs
$$--GLUE--$$
use axum::{
    http::{Request, StatusCode},
    middleware::{Next, FromRequestParts},
    response::Response,
};
use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,
    exp: u64,
    role: String,
}

pub async fn authenticate<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    if !auth_header.starts_with("Bearer ") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    let token = &auth_header["Bearer ".len()..];
    let key = DecodingKey::from_secret(b"your-secret-key"); // In production, use proper key management
    
    let validation = Validation::new(Algorithm::HS256);
    let claims = decode::<Claims>(token, &key, &validation)
        .map_err(|_| StatusCode::UNAUTHORIZED)?
        .claims;

    // Check token expiration
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    if claims.exp < now {
        return Err(StatusCode::UNAUTHORIZED);
    }

    Ok(next.run(req).await)
}

pub async fn authorize<B>(
    req: Request<B>,
    next: Next<B>,
) -> Result<Response, StatusCode> {
    // Implement role-based access control here
    // For example, check if the user has the required role for the endpoint
    Ok(next.run(req).await)
}

$$--GLUE--$$
.\src\security\mod.rs
$$--GLUE--$$
mod tls;
mod auth;
mod rate_limit;

pub use tls::TlsConfig;
pub use auth::{authenticate, authorize};
pub use rate_limit::rate_limit;

$$--GLUE--$$
.\src\security\rate_limit.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use std::time::{Instant, Duration};
use tower_http::limit::RateLimitLayer;
use tower::ServiceBuilder;

#[derive(Clone)]
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window,
        }
    }

    pub async fn check_rate_limit(&self, key: &str) -> bool {
        let mut requests = self.requests.lock().await;
        let now = Instant::now();
        
        // Clean up old requests
        requests.entry(key.to_string())
            .and_modify(|reqs| {
                reqs.retain(|&time| now.duration_since(time) < self.window);
            })
            .or_insert_with(Vec::new);
            
        let current_requests = requests.get(key).unwrap();
        
        if current_requests.len() >= self.max_requests {
            false
        } else {
            requests.get_mut(key).unwrap().push(now);
            true
        }
    }
}

pub fn rate_limit() -> RateLimitLayer {
    let rate_limit = RateLimitLayer::new(
        50, // requests
        Duration::from_secs(60), // per minute
    );
    
    ServiceBuilder::new()
        .layer(rate_limit)
        .into_inner()
}
$$--GLUE--$$
.\src\security\tls.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio_rustls::rustls::{
    Certificate, PrivateKey,
    ServerConfig as RustlsServerConfig,
};
use tokio_rustls::TlsAcceptor;

pub struct TlsConfig {
    acceptor: TlsAcceptor,
}

impl TlsConfig {
    pub fn new(cert_path: &str, key_path: &str) -> std::io::Result<Self> {
        let certs = load_certs(cert_path)?;
        let key = load_private_key(key_path)?;
        
        let config = RustlsServerConfig::builder()
            .with_safe_defaults()
            .with_no_client_auth()
            .with_single_cert(certs, key)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
            
        Ok(Self {
            acceptor: TlsAcceptor::from(Arc::new(config)),
        })
    }

    pub fn get_acceptor(&self) -> TlsAcceptor {
        self.acceptor.clone()
    }
}

fn load_certs(path: &str) -> std::io::Result<Vec<Certificate>> {
    let cert_file = std::fs::read(path)?;
    let certs = rustls_pemfile::certs(&mut &cert_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load certificate"
        ))?
        .into_iter()
        .map(Certificate)
        .collect();
    Ok(certs)
}

fn load_private_key(path: &str) -> std::io::Result<PrivateKey> {
    let key_file = std::fs::read(path)?;
    let key = rustls_pemfile::pkcs8_private_keys(&mut &key_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load private key"
        ))?
        .into_iter()
        .next()
        .ok_or_else(|| std::io::Error::new(
            std::io::ErrorKind::Other,
            "no private key found"
        ))?;
    Ok(PrivateKey(key))
}
$$--GLUE--$$
.\src\store.rs
$$--GLUE--$$
// src/store/mod.rs
use crate::types::{Result, Error, Service};
use sled::Db;
use std::path::Path;
use serde_json;

pub struct Store {
    db: Db,
}

impl Store {
    pub fn new<P: AsRef<Path>>(path: P) -> Result<Self> {
        let db = sled::open(path)?;
        Ok(Self { db })
    }

    pub fn set(&self, key: &str, value: &Service) -> Result<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| Error::Storage(e.to_string()))?;
        
        self.db
            .insert(key.as_bytes(), serialized)
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn get(&self, key: &str) -> Result<Option<Service>> {
        if let Some(data) = self.db.get(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))? {
            let service: Service = serde_json::from_slice(&data)
                .map_err(|e| Error::Storage(e.to_string()))?;
            Ok(Some(service))
        } else {
            Ok(None)
        }
    }

    pub fn delete(&self, key: &str) -> Result<()> {
        self.db
            .remove(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn scan_prefix(&self, prefix: &str) -> Result<Vec<Service>> {
        let mut services = Vec::new();
        
        for item in self.db.scan_prefix(prefix.as_bytes()) {
            let (_, value) = item.map_err(|e| Error::Storage(e.to_string()))?;
            let service: Service = serde_json::from_slice(&value)
                .map_err(|e| Error::Storage(e.to_string()))?;
            services.push(service);
        }
        
        Ok(services)
    }
}
$$--GLUE--$$
.\src\types.rs
$$--GLUE--$$
// src/types.rs

use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Storage error: {0}")]
    Storage(String),
    
    #[error("Service not found: {0}")]
    NotFound(String),
    
    #[error("Invalid request: {0}")]
    BadRequest(String),
    
    #[error("Raft error: {0}")]
    Raft(#[from] raft::Error),
    
    #[error("Auth error: {0}")]
    Auth(String),
    
    #[error("Rate limit exceeded")]
    RateLimit,

    #[error("Config error: {0}")]
    Config(String),

    #[error("Sled error: {0}")]
    Sled(#[from] sled::Error),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Service {
    pub id: String,
    pub name: String,
    pub address: String,
    pub port: u16,
    pub health_check_url: String,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
}

impl Service {
    pub fn new(name: String, address: String, port: u16) -> Self {
        let address_clone = address.clone();
        Self {
            id: Uuid::new_v4().to_string(),
            name,
            address,
            port,
            health_check_url: format!("http://{}:{}/health", address_clone, port),
            tags: Vec::new(),
            metadata: HashMap::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheck {
    pub status: HealthStatus,
    pub message: Option<String>,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}
$$--GLUE--$$
.\src\config.rs
$$--GLUE--$$
use config::{Config, ConfigError, File};
use serde::Deserialize;
use std::time::Duration;

#[derive(Debug, Deserialize, Clone)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Deserialize, Clone)]
pub struct SecurityConfig {
    pub jwt_secret: String,
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RaftConfig {
    pub node_id: u64,
    pub peers: Vec<u64>,
    pub election_timeout: u64,
    pub heartbeat_interval: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: usize,
    pub reset_timeout: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RateLimitConfig {
    pub requests_per_minute: u32,
    pub burst: u32,
}

#[derive(Debug, Deserialize, Clone)]
pub struct Settings {
    pub server: ServerConfig,
    pub security: SecurityConfig,
    pub raft: RaftConfig,
    pub circuit_breaker: CircuitBreakerConfig,
    pub rate_limit: RateLimitConfig,
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let mut config = Config::new();
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;

        config.deserialize()
    }

    pub fn circuit_breaker_reset_timeout(&self) -> Duration {
        Duration::from_secs(self.circuit_breaker.reset_timeout)
    }

    pub fn raft_election_timeout(&self) -> Duration {
        Duration::from_millis(self.raft.election_timeout)
    }

    pub fn raft_heartbeat_interval(&self) -> Duration {
        Duration::from_millis(self.raft.heartbeat_interval)
    }
}
$$--GLUE--$$
.\src\consensus\mod.rs
$$--GLUE--$$
mod raft;
mod state;

pub use raft::RaftNode;
pub use state::RaftStorage;
use raft::storage::RaftState;
$$--GLUE--$$
.\src\consensus\raft.rs
$$--GLUE--$$
use raft::{
    prelude::*,
    Config, RawNode, StateRole,
};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;
use super::state::RaftStorage;

pub struct RaftNode {
    id: u64,
    node: RawNode<RaftStorage>,
    store: Arc<Store>,
    logger: Logger,
}

impl RaftNode {
    pub fn new(
        id: u64,
        peers: Vec<u64>,
        store: Arc<Store>,
        logger: Logger,
    ) -> raft::Result<Self> {
        let config = Config {
            id,
            election_tick: 10,
            heartbeat_tick: 3,
            ..Default::default()
        };

        let storage = RaftStorage::new(store.clone(), logger.clone());
        let node = RawNode::new(&config, storage, &logger)?;

        Ok(Self { 
            id,
            node,
            store,
            logger,
        })
    }

    pub async fn tick(&mut self) {
        self.node.tick();
    }

    pub async fn propose(&mut self, data: Vec<u8>) -> raft::Result<()> {
        self.node.propose(vec![], data)?;
        Ok(())
    }

    pub async fn step(&mut self, msg: Message) -> raft::Result<()> {
        self.node.step(msg)?;
        Ok(())
    }

    pub async fn advance(&mut self) {
        self.node.advance(Ready::default());
    }

    pub async fn campaign(&mut self) -> raft::Result<()> {
        self.node.campaign()?;
        Ok(())
    }

    pub fn is_leader(&self) -> bool {
        self.node.raft.state == StateRole::Leader
    }
}
$$--GLUE--$$
.\src\consensus\state.rs
$$--GLUE--$$
use raft::prelude::*; // This includes all the necessary eraftpb types
use raft::{GetEntriesContext, RaftState, Result as RaftResult, Storage};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;

pub struct RaftStorage {
    store: Arc<Store>,
    hard_state: HardState,
    snapshot: Snapshot,
    logger: Logger,
}

impl RaftStorage {
    pub fn new(store: Arc<Store>, logger: Logger) -> Self {
        Self {
            store,
            hard_state: HardState::default(),
            snapshot: Snapshot::default(),
            logger,
        }
    }
}

impl Storage for RaftStorage {
    fn initial_state(&self) -> RaftResult<RaftState> {
        Ok(RaftState {
            hard_state: self.hard_state.clone(),
            conf_state: ConfState::default(),
        })
    }

    fn entries(
        &self,
        low: u64,
        high: u64,
        max_size: impl Into<Option<u64>>,
        context: GetEntriesContext,
    ) -> RaftResult<Vec<Entry>> {
        // Implement entry retrieval from storage
        Ok(vec![])
    }

    fn term(&self, idx: u64) -> RaftResult<u64> {
        // Implement term lookup
        Ok(0)
    }

    fn first_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn last_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn snapshot(&self, request_index: u64, to: u64) -> RaftResult<Snapshot> {
        Ok(self.snapshot.clone())
    }
}

$$--GLUE--$$
.\src\discovery.rs
$$--GLUE--$$
// src/discovery/mod.rs
use crate::types::{Result, Error, Service, HealthCheck, HealthStatus};
use crate::store::Store;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{self, Duration};
use reqwest;

pub struct ServiceRegistry {
    store: Arc<Store>,
    health_checks: RwLock<Vec<String>>,
}

impl ServiceRegistry {
    pub fn new(store: Arc<Store>) -> Self {
        let registry = Self {
            store,
            health_checks: RwLock::new(Vec::new()),
        };
        
        // Spawn health check task
        tokio::spawn(registry.clone().run_health_checks());
        
        registry
    }

    pub async fn register(&self, service: Service) -> Result<()> {
        self.store.set(&service.id, &service)?;
        
        let mut health_checks = self.health_checks.write().await;
        health_checks.push(service.id.clone());
        
        Ok(())
    }

    pub async fn deregister(&self, service_id: &str) -> Result<()> {
        self.store.delete(service_id)?;
        
        let mut health_checks = self.health_checks.write().await;
        if let Some(pos) = health_checks.iter().position(|id| id == service_id) {
            health_checks.remove(pos);
        }
        
        Ok(())
    }

    pub async fn get_service(&self, service_id: &str) -> Result<Option<Service>> {
        self.store.get(service_id)
    }

    pub async fn get_services_by_name(&self, name: &str) -> Result<Vec<Service>> {
        self.store.scan_prefix(&format!("service:{}", name))
    }

    async fn run_health_checks(self) {
        let mut interval = time::interval(Duration::from_secs(10));
        
        loop {
            interval.tick().await;
            
            let health_checks = self.health_checks.read().await;
            for service_id in health_checks.iter() {
                if let Ok(Some(service)) = self.store.get(service_id) {
                    let health = self.check_health(&service).await;
                    if health.status == HealthStatus::Unhealthy {
                        tracing::warn!("Service {} failed health check: {:?}", service_id, health.message);
                    }
                }
            }
        }
    }

    async fn check_health(&self, service: &Service) -> HealthCheck {
        match reqwest::get(&service.health_check_url).await {
            Ok(response) => HealthCheck {
                status: if response.status().is_success() { 
                    HealthStatus::Healthy 
                } else { 
                    HealthStatus::Unhealthy 
                },
                message: None,
                timestamp: chrono::Utc::now(),
            },
            Err(e) => HealthCheck {
                status: HealthStatus::Unhealthy,
                message: Some(e.to_string()),
                timestamp: chrono::Utc::now(),
            },
        }
    }
}

impl Clone for ServiceRegistry {
    fn clone(&self) -> Self {
        Self {
            store: Arc::clone(&self.store),
            health_checks: RwLock::new(Vec::new()),
        }
    }
}
$$--GLUE--$$
.\src\main.rs
$$--GLUE--$$
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::sync::RwLock;
use axum::serve;
use tokio::net::TcpListener;
use slog::{Logger, Drain};

mod config;
mod consensus;
mod discovery;
mod router;
mod security;
mod store;
mod types;

use crate::config::Settings;
use crate::consensus::RaftNode;
use crate::discovery::ServiceRegistry;
use crate::router::Router;
use crate::security::TlsConfig;
use crate::store::Store;
use crate::types::{Result, Error};

// Implement From for ConfigError using the proper path
impl From<::config::ConfigError> for Error {
    fn from(err: ::config::ConfigError) -> Self {
        Error::Config(err.to_string())
    }
}

// Implement From for std::net::AddrParseError
impl From<std::net::AddrParseError> for Error {
    fn from(err: std::net::AddrParseError) -> Self {
        Error::BadRequest(err.to_string())
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt::init();

    // Initialize slog logger
    let decorator = slog_term::TermDecorator::new().build();
    let drain = slog_term::FullFormat::new(decorator).build().fuse();
    let drain = slog_async::Async::new(drain).build().fuse();
    let logger = Logger::root(drain, slog::o!());

    // Load configuration
    let settings = Settings::new()?;

    // Initialize the storage layer
    let store = Arc::new(Store::new("data")?);
    
    // Initialize Raft consensus
    let raft_node = Arc::new(RwLock::new(RaftNode::new(
        settings.raft.node_id,
        settings.raft.peers.clone(),
        store.clone(),
        logger.clone(),
    )?));
    
    // Initialize the service registry
    let registry = Arc::new(RwLock::new(ServiceRegistry::new(store.clone())));
    
    // Initialize TLS
    let tls_config = TlsConfig::new(
        &settings.security.cert_path,
        &settings.security.key_path,
    )?;
    
    // Initialize the router with all features
    let app = Router::new(registry.clone());

    // Start Raft ticker
    let raft_clone = raft_node.clone();
    let settings_clone = settings.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(settings_clone.raft_heartbeat_interval());
        loop {
            interval.tick().await;
            if let Ok(mut node) = raft_clone.write().await {
                if let Err(e) = node.tick().await {
                    tracing::error!("Raft tick error: {}", e);
                }
            }
        }
    });

    // Start the HTTP server
    let addr = SocketAddr::new(
        settings.server.host.parse()?,
        settings.server.port,
    );
    
    tracing::info!("Starting server on {}", addr);
    
    // Create TcpListener
    let listener = TcpListener::bind(addr).await?;
    let acceptor = tls_config.get_acceptor();
    
    serve(
        listener,
        app.into_make_service()
    )
    .await?;

    Ok(())
}
$$--GLUE--$$
.\src\router\balancer.rs
$$--GLUE--$$
use rand::seq::SliceRandom;
use std::sync::Arc;
use dashmap::DashMap;
use crate::types::Service;

#[derive(Debug, Clone)]
pub struct LoadBalancer {
    services: Arc<DashMap<String, Vec<Service>>>,
}

impl LoadBalancer {
    pub fn new() -> Self {
        Self {
            services: Arc::new(DashMap::new()),
        }
    }

    pub fn add_service(&self, service: Service) {
        self.services
            .entry(service.name.clone())
            .or_default()
            .push(service);
    }

    pub fn get_service(&self, name: &str) -> Option<Service> {
        self.services.get(name).and_then(|services| {
            services.choose(&mut rand::thread_rng()).cloned()
        })
    }
}
$$--GLUE--$$
.\src\router\cache.rs
$$--GLUE--$$
use std::time::Duration;
use moka::future::Cache;
use crate::types::Service;

pub struct RouteCache {
    cache: Cache<String, Vec<Service>>,
}

impl RouteCache {
    pub fn new() -> Self {
        Self {
            cache: Cache::builder()
                .time_to_live(Duration::from_secs(30))
                .time_to_idle(Duration::from_secs(10))
                .max_capacity(100)
                .build(),
        }
    }

    pub async fn get(&self, key: &str) -> Option<Vec<Service>> {
        self.cache.get(key).await
    }

    pub async fn insert(&self, key: String, value: Vec<Service>) {
        self.cache.insert(key, value).await;
    }

    pub async fn invalidate(&self, key: &str) {
        self.cache.invalidate(key).await;
    }
}

impl Default for RouteCache {
    fn default() -> Self {
        Self::new()
    }
}
$$--GLUE--$$
.\src\router\circuit_breaker.rs
$$--GLUE--$$
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

pub struct CircuitBreaker {
    failure_threshold: usize,
    reset_timeout: Duration,
    failures: AtomicUsize,
    last_failure: RwLock<Option<Instant>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: usize, reset_timeout: Duration) -> Self {
        Self {
            failure_threshold,
            reset_timeout,
            failures: AtomicUsize::new(0),
            last_failure: RwLock::new(None),
        }
    }

    pub async fn record_success(&self) {
        self.failures.store(0, Ordering::SeqCst);
        *self.last_failure.write().await = None;
    }

    pub async fn record_failure(&self) -> bool {
        let failures = self.failures.fetch_add(1, Ordering::SeqCst) + 1;
        *self.last_failure.write().await = Some(Instant::now());
        failures >= self.failure_threshold
    }

    pub async fn is_open(&self) -> bool {
        let failures = self.failures.load(Ordering::SeqCst);
        if failures < self.failure_threshold {
            return false;
        }

        if let Some(last_failure) = *self.last_failure.read().await {
            if last_failure.elapsed() > self.reset_timeout {
                self.failures.store(0, Ordering::SeqCst);
                return false;
            }
        }

        true
    }
}

$$--GLUE--$$
.\src\router\mod.rs
$$--GLUE--$$
mod routes;
mod balancer;
mod circuit_breaker;
mod cache;
mod websocket;

pub use routes::Router;
pub use balancer::LoadBalancer;
pub use circuit_breaker::CircuitBreaker;
pub use cache::RouteCache;
pub use websocket::WebSocketHandler;
$$--GLUE--$$
.\src\router\routes.rs
$$--GLUE--$$
use axum::{
    Router as AxumRouter,
    routing::{get, post, delete},
    extract::{State, Path},
    Json,
    response::IntoResponse,
    http::StatusCode,
};
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::{
    discovery::ServiceRegistry,
    types::{Service, Error},
};

pub struct Router {
    registry: Arc<RwLock<ServiceRegistry>>,
}

impl Router {
    pub fn new(registry: Arc<RwLock<ServiceRegistry>>) -> AxumRouter {
        let shared_state = Arc::new(Self { registry });

        AxumRouter::new()
            .route("/services", post(Self::register_service))
            .route("/services/:id", get(Self::get_service))
            .route("/services/:id", delete(Self::deregister_service))
            .with_state(shared_state)
    }

    async fn register_service(
        State(state): State<Arc<Router>>,
        Json(service): Json<Service>,
    ) -> Result<(StatusCode, Json<Service>), Error> {
        state.registry.write().await.register(service.clone()).await?;
        Ok((StatusCode::CREATED, Json(service)))
    }

    async fn get_service(
        State(state): State<Arc<Router>>,
        Path(id): Path<String>,
    ) -> Result<Json<Option<Service>>, Error> {
        let service = state.registry.read().await.get_service(&id).await?;
        Ok(Json(service))
    }

    async fn deregister_service(
        State(state): State<Arc<Router>>,
        Path(id): Path<String>,
    ) -> Result<StatusCode, Error> {
        state.registry.write().await.deregister(&id).await?;
        Ok(StatusCode::NO_CONTENT)
    }
}

// Implement IntoResponse for Error to properly handle errors
impl IntoResponse for Error {
    fn into_response(self) -> axum::response::Response {
        let status = match self {
            Error::NotFound(_) => StatusCode::NOT_FOUND,
            Error::BadRequest(_) => StatusCode::BAD_REQUEST,
            Error::Auth(_) => StatusCode::UNAUTHORIZED,
            Error::RateLimit => StatusCode::TOO_MANY_REQUESTS,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        };
        (status, self.to_string()).into_response()
    }
}
$$--GLUE--$$
.\src\router\websocket.rs
$$--GLUE--$$
use axum::{
    extract::ws::{WebSocket, WebSocketUpgrade},
    response::Response,
};
use futures::{sink::SinkExt, stream::StreamExt};

pub struct WebSocketHandler;

impl WebSocketHandler {
    pub async fn handle_upgrade(ws: WebSocketUpgrade) -> Response {
        ws.on_upgrade(Self::handle_socket)
    }

    async fn handle_socket(mut socket: WebSocket) {
        while let Some(msg) = socket.recv().await {
            if let Ok(msg) = msg {
                if socket.send(msg).await.is_err() {
                    break;
                }
            } else {
                break;
            }
        }
    }
}
$$--GLUE--$$
.\src\security\auth.rs
$$--GLUE--$$
use axum::{
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
    body::Body,
};
use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,
    exp: u64,
    role: String,
}

pub async fn authenticate(
    req: Request<Body>,
    next: Next<Body>,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    if !auth_header.starts_with("Bearer ") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    let token = &auth_header["Bearer ".len()..];
    let key = DecodingKey::from_secret(b"your-secret-key"); // In production, use proper key management
    
    let validation = Validation::new(Algorithm::HS256);
    let claims = decode::<Claims>(token, &key, &validation)
        .map_err(|_| StatusCode::UNAUTHORIZED)?
        .claims;

    // Check token expiration
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    if claims.exp < now {
        return Err(StatusCode::UNAUTHORIZED);
    }

    Ok(next.run(req).await)
}

pub async fn authorize(
    req: Request<Body>,
    next: Next<Body>,
) -> Result<Response, StatusCode> {
    // Implement role-based access control here
    Ok(next.run(req).await)
}
$$--GLUE--$$
.\src\security\mod.rs
$$--GLUE--$$
mod tls;
mod auth;
mod rate_limit;

pub use tls::TlsConfig;
pub use auth::{authenticate, authorize};
pub use rate_limit::rate_limit;

$$--GLUE--$$
.\src\security\rate_limit.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use std::time::{Instant, Duration};
use tower::limit::RateLimitLayer;
use tower::ServiceBuilder;

#[derive(Clone)]
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window,
        }
    }

    pub async fn check_rate_limit(&self, key: &str) -> bool {
        let mut requests = self.requests.lock().await;
        let now = Instant::now();
        
        // Clean up old requests
        requests.entry(key.to_string())
            .and_modify(|reqs| {
                reqs.retain(|&time| now.duration_since(time) < self.window);
            })
            .or_insert_with(Vec::new);
            
        let current_requests = requests.get(key).unwrap();
        
        if current_requests.len() >= self.max_requests {
            false
        } else {
            requests.get_mut(key).unwrap().push(now);
            true
        }
    }
}

pub fn rate_limit() -> RateLimitLayer {
    RateLimitLayer::new(
        50, // requests
        Duration::from_secs(60), // per minute
    )
}
$$--GLUE--$$
.\src\security\tls.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio_rustls::rustls::{
    Certificate, PrivateKey,
    ServerConfig as RustlsServerConfig,
};
use tokio_rustls::TlsAcceptor;

pub struct TlsConfig {
    acceptor: TlsAcceptor,
}

impl TlsConfig {
    pub fn new(cert_path: &str, key_path: &str) -> std::io::Result<Self> {
        let certs = load_certs(cert_path)?;
        let key = load_private_key(key_path)?;
        
        let config = RustlsServerConfig::builder()
            .with_safe_defaults()
            .with_no_client_auth()
            .with_single_cert(certs, key)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
            
        Ok(Self {
            acceptor: TlsAcceptor::from(Arc::new(config)),
        })
    }

    pub fn get_acceptor(&self) -> TlsAcceptor {
        self.acceptor.clone()
    }
}

fn load_certs(path: &str) -> std::io::Result<Vec<Certificate>> {
    let cert_file = std::fs::read(path)?;
    let certs = rustls_pemfile::certs(&mut &cert_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load certificate"
        ))?
        .into_iter()
        .map(Certificate)
        .collect();
    Ok(certs)
}

fn load_private_key(path: &str) -> std::io::Result<PrivateKey> {
    let key_file = std::fs::read(path)?;
    let key = rustls_pemfile::pkcs8_private_keys(&mut &key_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load private key"
        ))?
        .into_iter()
        .next()
        .ok_or_else(|| std::io::Error::new(
            std::io::ErrorKind::Other,
            "no private key found"
        ))?;
    Ok(PrivateKey(key))
}
$$--GLUE--$$
.\src\store.rs
$$--GLUE--$$
// src/store/mod.rs
use crate::types::{Result, Error, Service};
use sled::Db;
use std::path::Path;
use serde_json;

pub struct Store {
    db: Db,
}

impl Store {
    pub fn new<P: AsRef<Path>>(path: P) -> Result<Self> {
        let db = sled::open(path)?;
        Ok(Self { db })
    }

    pub fn set(&self, key: &str, value: &Service) -> Result<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| Error::Storage(e.to_string()))?;
        
        self.db
            .insert(key.as_bytes(), serialized)
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn get(&self, key: &str) -> Result<Option<Service>> {
        if let Some(data) = self.db.get(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))? {
            let service: Service = serde_json::from_slice(&data)
                .map_err(|e| Error::Storage(e.to_string()))?;
            Ok(Some(service))
        } else {
            Ok(None)
        }
    }

    pub fn delete(&self, key: &str) -> Result<()> {
        self.db
            .remove(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn scan_prefix(&self, prefix: &str) -> Result<Vec<Service>> {
        let mut services = Vec::new();
        
        for item in self.db.scan_prefix(prefix.as_bytes()) {
            let (_, value) = item.map_err(|e| Error::Storage(e.to_string()))?;
            let service: Service = serde_json::from_slice(&value)
                .map_err(|e| Error::Storage(e.to_string()))?;
            services.push(service);
        }
        
        Ok(services)
    }
}
$$--GLUE--$$
.\src\types.rs
$$--GLUE--$$
// src/types.rs

use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Storage error: {0}")]
    Storage(String),
    
    #[error("Service not found: {0}")]
    NotFound(String),
    
    #[error("Invalid request: {0}")]
    BadRequest(String),
    
    #[error("Raft error: {0}")]
    Raft(#[from] raft::Error),
    
    #[error("Auth error: {0}")]
    Auth(String),
    
    #[error("Rate limit exceeded")]
    RateLimit,

    #[error("Config error: {0}")]
    Config(String),

    #[error("Sled error: {0}")]
    Sled(#[from] sled::Error),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Service {
    pub id: String,
    pub name: String,
    pub address: String,
    pub port: u16,
    pub health_check_url: String,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
}

impl Service {
    pub fn new(name: String, address: String, port: u16) -> Self {
        let address_clone = address.clone();
        Self {
            id: Uuid::new_v4().to_string(),
            name,
            address,
            port,
            health_check_url: format!("http://{}:{}/health", address_clone, port),
            tags: Vec::new(),
            metadata: HashMap::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheck {
    pub status: HealthStatus,
    pub message: Option<String>,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}
$$--GLUE--$$
.\src\config.rs
$$--GLUE--$$
use config::{Config, ConfigError, File};
use serde::Deserialize;
use std::time::Duration;

#[derive(Debug, Deserialize, Clone)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Deserialize, Clone)]
pub struct SecurityConfig {
    pub jwt_secret: String,
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RaftConfig {
    pub node_id: u64,
    pub peers: Vec<u64>,
    pub election_timeout: u64,
    pub heartbeat_interval: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: usize,
    pub reset_timeout: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RateLimitConfig {
    pub requests_per_minute: u32,
    pub burst: u32,
}

#[derive(Debug, Deserialize, Clone)]
pub struct Settings {
    pub server: ServerConfig,
    pub security: SecurityConfig,
    pub raft: RaftConfig,
    pub circuit_breaker: CircuitBreakerConfig,
    pub rate_limit: RateLimitConfig,
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let mut config = Config::new();
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;

        config.deserialize()
    }

    pub fn circuit_breaker_reset_timeout(&self) -> Duration {
        Duration::from_secs(self.circuit_breaker.reset_timeout)
    }

    pub fn raft_election_timeout(&self) -> Duration {
        Duration::from_millis(self.raft.election_timeout)
    }

    pub fn raft_heartbeat_interval(&self) -> Duration {
        Duration::from_millis(self.raft.heartbeat_interval)
    }
}
$$--GLUE--$$
.\src\consensus\mod.rs
$$--GLUE--$$
mod raft;
mod state;

pub use raft::RaftNode;
pub use state::RaftStorage;

$$--GLUE--$$
.\src\consensus\raft.rs
$$--GLUE--$$
use raft::{
    prelude::*,
    Config, RawNode, StateRole,
};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;
use super::state::RaftStorage;

pub struct RaftNode {
    id: u64,
    node: RawNode<RaftStorage>,
    store: Arc<Store>,
    logger: Logger,
}

impl RaftNode {
    pub fn new(
        id: u64,
        peers: Vec<u64>,
        store: Arc<Store>,
        logger: Logger,
    ) -> raft::Result<Self> {
        let config = Config {
            id,
            election_tick: 10,
            heartbeat_tick: 3,
            ..Default::default()
        };

        let storage = RaftStorage::new(store.clone(), logger.clone());
        let node = RawNode::new(&config, storage, &logger)?;

        Ok(Self { 
            id,
            node,
            store,
            logger,
        })
    }

    pub async fn tick(&mut self) {
        self.node.tick();
    }

    pub async fn propose(&mut self, data: Vec<u8>) -> raft::Result<()> {
        self.node.propose(vec![], data)?;
        Ok(())
    }

    pub async fn step(&mut self, msg: Message) -> raft::Result<()> {
        self.node.step(msg)?;
        Ok(())
    }

    pub async fn advance(&mut self) {
        self.node.advance(Ready::default());
    }

    pub async fn campaign(&mut self) -> raft::Result<()> {
        self.node.campaign()?;
        Ok(())
    }

    pub fn is_leader(&self) -> bool {
        self.node.raft.state == StateRole::Leader
    }
}
$$--GLUE--$$
.\src\consensus\state.rs
$$--GLUE--$$
use raft::prelude::*; // This includes all the necessary eraftpb types
use raft::{GetEntriesContext, RaftState, Result as RaftResult, Storage};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;

pub struct RaftStorage {
    store: Arc<Store>,
    hard_state: HardState,
    snapshot: Snapshot,
    logger: Logger,
}

impl RaftStorage {
    pub fn new(store: Arc<Store>, logger: Logger) -> Self {
        Self {
            store,
            hard_state: HardState::default(),
            snapshot: Snapshot::default(),
            logger,
        }
    }
}

impl Storage for RaftStorage {
    fn initial_state(&self) -> RaftResult<RaftState> {
        Ok(RaftState {
            hard_state: self.hard_state.clone(),
            conf_state: ConfState::default(),
        })
    }

    fn entries(
        &self,
        low: u64,
        high: u64,
        max_size: impl Into<Option<u64>>,
        context: GetEntriesContext,
    ) -> RaftResult<Vec<Entry>> {
        // Implement entry retrieval from storage
        Ok(vec![])
    }

    fn term(&self, idx: u64) -> RaftResult<u64> {
        // Implement term lookup
        Ok(0)
    }

    fn first_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn last_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn snapshot(&self, request_index: u64, to: u64) -> RaftResult<Snapshot> {
        Ok(self.snapshot.clone())
    }
}

$$--GLUE--$$
.\src\discovery.rs
$$--GLUE--$$
// src/discovery/mod.rs
use crate::types::{Result, Error, Service, HealthCheck, HealthStatus};
use crate::store::Store;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{self, Duration};
use reqwest;

pub struct ServiceRegistry {
    store: Arc<Store>,
    health_checks: RwLock<Vec<String>>,
}

impl ServiceRegistry {
    pub fn new(store: Arc<Store>) -> Self {
        let registry = Self {
            store,
            health_checks: RwLock::new(Vec::new()),
        };
        
        // Spawn health check task
        tokio::spawn(registry.clone().run_health_checks());
        
        registry
    }

    pub async fn register(&self, service: Service) -> Result<()> {
        self.store.set(&service.id, &service)?;
        
        let mut health_checks = self.health_checks.write().await;
        health_checks.push(service.id.clone());
        
        Ok(())
    }

    pub async fn deregister(&self, service_id: &str) -> Result<()> {
        self.store.delete(service_id)?;
        
        let mut health_checks = self.health_checks.write().await;
        if let Some(pos) = health_checks.iter().position(|id| id == service_id) {
            health_checks.remove(pos);
        }
        
        Ok(())
    }

    pub async fn get_service(&self, service_id: &str) -> Result<Option<Service>> {
        self.store.get(service_id)
    }

    pub async fn get_services_by_name(&self, name: &str) -> Result<Vec<Service>> {
        self.store.scan_prefix(&format!("service:{}", name))
    }

    async fn run_health_checks(self) {
        let mut interval = time::interval(Duration::from_secs(10));
        
        loop {
            interval.tick().await;
            
            let health_checks = self.health_checks.read().await;
            for service_id in health_checks.iter() {
                if let Ok(Some(service)) = self.store.get(service_id) {
                    let health = self.check_health(&service).await;
                    if health.status == HealthStatus::Unhealthy {
                        tracing::warn!("Service {} failed health check: {:?}", service_id, health.message);
                    }
                }
            }
        }
    }

    async fn check_health(&self, service: &Service) -> HealthCheck {
        match reqwest::get(&service.health_check_url).await {
            Ok(response) => HealthCheck {
                status: if response.status().is_success() { 
                    HealthStatus::Healthy 
                } else { 
                    HealthStatus::Unhealthy 
                },
                message: None,
                timestamp: chrono::Utc::now(),
            },
            Err(e) => HealthCheck {
                status: HealthStatus::Unhealthy,
                message: Some(e.to_string()),
                timestamp: chrono::Utc::now(),
            },
        }
    }
}

impl Clone for ServiceRegistry {
    fn clone(&self) -> Self {
        Self {
            store: Arc::clone(&self.store),
            health_checks: RwLock::new(Vec::new()),
        }
    }
}
$$--GLUE--$$
.\src\main.rs
$$--GLUE--$$
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::sync::RwLock;
use axum::serve;
use tokio::net::TcpListener;
use slog::{Logger, Drain};

mod config;
mod consensus;
mod discovery;
mod router;
mod security;
mod store;
mod types;

use crate::config::Settings;
use crate::consensus::RaftNode;
use crate::discovery::ServiceRegistry;
use crate::router::Router;
use crate::security::TlsConfig;
use crate::store::Store;
use crate::types::{Result, Error};

// Implement From for ConfigError using the proper path
impl From<::config::ConfigError> for Error {
    fn from(err: ::config::ConfigError) -> Self {
        Error::Config(err.to_string())
    }
}

// Implement From for std::net::AddrParseError
impl From<std::net::AddrParseError> for Error {
    fn from(err: std::net::AddrParseError) -> Self {
        Error::BadRequest(err.to_string())
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt::init();

    // Initialize slog logger
    let decorator = slog_term::TermDecorator::new().build();
    let drain = slog_term::FullFormat::new(decorator).build().fuse();
    let drain = slog_async::Async::new(drain).build().fuse();
    let logger = Logger::root(drain, slog::o!());

    // Load configuration
    let settings = Settings::new()?;

    // Initialize the storage layer
    let store = Arc::new(Store::new("data")?);
    
    // Initialize Raft consensus
    let raft_node = Arc::new(RwLock::new(RaftNode::new(
        settings.raft.node_id,
        settings.raft.peers.clone(),
        store.clone(),
        logger.clone(),
    )?));
    
    // Initialize the service registry
    let registry = Arc::new(RwLock::new(ServiceRegistry::new(store.clone())));
    
    // Initialize TLS
    let tls_config = TlsConfig::new(
        &settings.security.cert_path,
        &settings.security.key_path,
    )?;
    
    // Initialize the router with all features
    let app = Router::new(registry.clone());

    // Start Raft ticker
    let raft_clone = raft_node.clone();
    let settings_clone = settings.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(settings_clone.raft_heartbeat_interval());
        loop {
            interval.tick().await;
            let mut node = raft_clone.write().await;
        }
    });

    // Start the HTTP server
    let addr = SocketAddr::new(
        settings.server.host.parse()?,
        settings.server.port,
    );
    
    tracing::info!("Starting server on {}", addr);
    
    // Create TcpListener
    let listener = TcpListener::bind(addr).await?;
    let acceptor = tls_config.get_acceptor();
    
    serve(
        listener,
        app.into_make_service()
    )
    .await?;

    Ok(())
}
$$--GLUE--$$
.\src\router\balancer.rs
$$--GLUE--$$
use rand::seq::SliceRandom;
use std::sync::Arc;
use dashmap::DashMap;
use crate::types::Service;

#[derive(Debug, Clone)]
pub struct LoadBalancer {
    services: Arc<DashMap<String, Vec<Service>>>,
}

impl LoadBalancer {
    pub fn new() -> Self {
        Self {
            services: Arc::new(DashMap::new()),
        }
    }

    pub fn add_service(&self, service: Service) {
        self.services
            .entry(service.name.clone())
            .or_default()
            .push(service);
    }

    pub fn get_service(&self, name: &str) -> Option<Service> {
        self.services.get(name).and_then(|services| {
            services.choose(&mut rand::thread_rng()).cloned()
        })
    }
}
$$--GLUE--$$
.\src\router\cache.rs
$$--GLUE--$$
use std::time::Duration;
use moka::future::Cache;
use crate::types::Service;

pub struct RouteCache {
    cache: Cache<String, Vec<Service>>,
}

impl RouteCache {
    pub fn new() -> Self {
        Self {
            cache: Cache::builder()
                .time_to_live(Duration::from_secs(30))
                .time_to_idle(Duration::from_secs(10))
                .max_capacity(100)
                .build(),
        }
    }

    pub async fn get(&self, key: &str) -> Option<Vec<Service>> {
        self.cache.get(key).await
    }

    pub async fn insert(&self, key: String, value: Vec<Service>) {
        self.cache.insert(key, value).await;
    }

    pub async fn invalidate(&self, key: &str) {
        self.cache.invalidate(key).await;
    }
}

impl Default for RouteCache {
    fn default() -> Self {
        Self::new()
    }
}
$$--GLUE--$$
.\src\router\circuit_breaker.rs
$$--GLUE--$$
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

pub struct CircuitBreaker {
    failure_threshold: usize,
    reset_timeout: Duration,
    failures: AtomicUsize,
    last_failure: RwLock<Option<Instant>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: usize, reset_timeout: Duration) -> Self {
        Self {
            failure_threshold,
            reset_timeout,
            failures: AtomicUsize::new(0),
            last_failure: RwLock::new(None),
        }
    }

    pub async fn record_success(&self) {
        self.failures.store(0, Ordering::SeqCst);
        *self.last_failure.write().await = None;
    }

    pub async fn record_failure(&self) -> bool {
        let failures = self.failures.fetch_add(1, Ordering::SeqCst) + 1;
        *self.last_failure.write().await = Some(Instant::now());
        failures >= self.failure_threshold
    }

    pub async fn is_open(&self) -> bool {
        let failures = self.failures.load(Ordering::SeqCst);
        if failures < self.failure_threshold {
            return false;
        }

        if let Some(last_failure) = *self.last_failure.read().await {
            if last_failure.elapsed() > self.reset_timeout {
                self.failures.store(0, Ordering::SeqCst);
                return false;
            }
        }

        true
    }
}

$$--GLUE--$$
.\src\router\mod.rs
$$--GLUE--$$
mod routes;
mod balancer;
mod circuit_breaker;
mod cache;
mod websocket;

pub use routes::Router;
pub use balancer::LoadBalancer;
pub use circuit_breaker::CircuitBreaker;
pub use cache::RouteCache;
pub use websocket::WebSocketHandler;
$$--GLUE--$$
.\src\router\routes.rs
$$--GLUE--$$
use axum::{
    Router as AxumRouter,
    routing::{get, post, delete},
    extract::{State, Path},
    Json,
    response::IntoResponse,
    http::StatusCode,
};
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::{
    discovery::ServiceRegistry,
    types::{Service, Error},
};

pub struct Router {
    registry: Arc<RwLock<ServiceRegistry>>,
}

impl Router {
    pub fn new(registry: Arc<RwLock<ServiceRegistry>>) -> AxumRouter {
        let shared_state = Arc::new(Self { registry });

        AxumRouter::new()
            .route("/services", post(Self::register_service))
            .route("/services/:id", get(Self::get_service))
            .route("/services/:id", delete(Self::deregister_service))
            .with_state(shared_state)
    }

    async fn register_service(
        State(state): State<Arc<Router>>,
        Json(service): Json<Service>,
    ) -> Result<(StatusCode, Json<Service>), Error> {
        state.registry.write().await.register(service.clone()).await?;
        Ok((StatusCode::CREATED, Json(service)))
    }

    async fn get_service(
        State(state): State<Arc<Router>>,
        Path(id): Path<String>,
    ) -> Result<Json<Option<Service>>, Error> {
        let service = state.registry.read().await.get_service(&id).await?;
        Ok(Json(service))
    }

    async fn deregister_service(
        State(state): State<Arc<Router>>,
        Path(id): Path<String>,
    ) -> Result<StatusCode, Error> {
        state.registry.write().await.deregister(&id).await?;
        Ok(StatusCode::NO_CONTENT)
    }
}

// Implement IntoResponse for Error to properly handle errors
impl IntoResponse for Error {
    fn into_response(self) -> axum::response::Response {
        let status = match self {
            Error::NotFound(_) => StatusCode::NOT_FOUND,
            Error::BadRequest(_) => StatusCode::BAD_REQUEST,
            Error::Auth(_) => StatusCode::UNAUTHORIZED,
            Error::RateLimit => StatusCode::TOO_MANY_REQUESTS,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        };
        (status, self.to_string()).into_response()
    }
}
$$--GLUE--$$
.\src\router\websocket.rs
$$--GLUE--$$
use axum::{
    extract::ws::{WebSocket, WebSocketUpgrade},
    response::Response,
};
use futures::{sink::SinkExt, stream::StreamExt};

pub struct WebSocketHandler;

impl WebSocketHandler {
    pub async fn handle_upgrade(ws: WebSocketUpgrade) -> Response {
        ws.on_upgrade(Self::handle_socket)
    }

    async fn handle_socket(mut socket: WebSocket) {
        while let Some(msg) = socket.recv().await {
            if let Ok(msg) = msg {
                if socket.send(msg).await.is_err() {
                    break;
                }
            } else {
                break;
            }
        }
    }
}
$$--GLUE--$$
.\src\security\auth.rs
$$--GLUE--$$
use axum::{
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
    body::Body,
};
use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,
    exp: u64,
    role: String,
}

pub async fn authenticate(
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    if !auth_header.starts_with("Bearer ") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    let token = &auth_header["Bearer ".len()..];
    let key = DecodingKey::from_secret(b"your-secret-key"); // In production, use proper key management
    
    let validation = Validation::new(Algorithm::HS256);
    let claims = decode::<Claims>(token, &key, &validation)
        .map_err(|_| StatusCode::UNAUTHORIZED)?
        .claims;

    // Check token expiration
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    if claims.exp < now {
        return Err(StatusCode::UNAUTHORIZED);
    }

    Ok(next.run(req).await)
}

pub async fn authorize(
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    // Implement role-based access control here
    Ok(next.run(req).await)
}
$$--GLUE--$$
.\src\security\mod.rs
$$--GLUE--$$
mod tls;
mod auth;
mod rate_limit;

pub use tls::TlsConfig;
pub use auth::{authenticate, authorize};
pub use rate_limit::rate_limit;

$$--GLUE--$$
.\src\security\rate_limit.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use std::time::{Instant, Duration};
use tower::limit::RateLimitLayer;
use tower::ServiceBuilder;

#[derive(Clone)]
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window,
        }
    }

    pub async fn check_rate_limit(&self, key: &str) -> bool {
        let mut requests = self.requests.lock().await;
        let now = Instant::now();
        
        // Clean up old requests
        requests.entry(key.to_string())
            .and_modify(|reqs| {
                reqs.retain(|&time| now.duration_since(time) < self.window);
            })
            .or_insert_with(Vec::new);
            
        let current_requests = requests.get(key).unwrap();
        
        if current_requests.len() >= self.max_requests {
            false
        } else {
            requests.get_mut(key).unwrap().push(now);
            true
        }
    }
}

pub fn rate_limit() -> RateLimitLayer {
    RateLimitLayer::new(
        50, // requests
        Duration::from_secs(60), // per minute
    )
}
$$--GLUE--$$
.\src\security\tls.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio_rustls::rustls::{
    Certificate, PrivateKey,
    ServerConfig as RustlsServerConfig,
};
use tokio_rustls::TlsAcceptor;

pub struct TlsConfig {
    acceptor: TlsAcceptor,
}

impl TlsConfig {
    pub fn new(cert_path: &str, key_path: &str) -> std::io::Result<Self> {
        let certs = load_certs(cert_path)?;
        let key = load_private_key(key_path)?;
        
        let config = RustlsServerConfig::builder()
            .with_safe_defaults()
            .with_no_client_auth()
            .with_single_cert(certs, key)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
            
        Ok(Self {
            acceptor: TlsAcceptor::from(Arc::new(config)),
        })
    }

    pub fn get_acceptor(&self) -> TlsAcceptor {
        self.acceptor.clone()
    }
}

fn load_certs(path: &str) -> std::io::Result<Vec<Certificate>> {
    let cert_file = std::fs::read(path)?;
    let certs = rustls_pemfile::certs(&mut &cert_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load certificate"
        ))?
        .into_iter()
        .map(Certificate)
        .collect();
    Ok(certs)
}

fn load_private_key(path: &str) -> std::io::Result<PrivateKey> {
    let key_file = std::fs::read(path)?;
    let key = rustls_pemfile::pkcs8_private_keys(&mut &key_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load private key"
        ))?
        .into_iter()
        .next()
        .ok_or_else(|| std::io::Error::new(
            std::io::ErrorKind::Other,
            "no private key found"
        ))?;
    Ok(PrivateKey(key))
}
$$--GLUE--$$
.\src\store.rs
$$--GLUE--$$
// src/store/mod.rs
use crate::types::{Result, Error, Service};
use sled::Db;
use std::path::Path;
use serde_json;

pub struct Store {
    db: Db,
}

impl Store {
    pub fn new<P: AsRef<Path>>(path: P) -> Result<Self> {
        let db = sled::open(path)?;
        Ok(Self { db })
    }

    pub fn set(&self, key: &str, value: &Service) -> Result<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| Error::Storage(e.to_string()))?;
        
        self.db
            .insert(key.as_bytes(), serialized)
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn get(&self, key: &str) -> Result<Option<Service>> {
        if let Some(data) = self.db.get(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))? {
            let service: Service = serde_json::from_slice(&data)
                .map_err(|e| Error::Storage(e.to_string()))?;
            Ok(Some(service))
        } else {
            Ok(None)
        }
    }

    pub fn delete(&self, key: &str) -> Result<()> {
        self.db
            .remove(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn scan_prefix(&self, prefix: &str) -> Result<Vec<Service>> {
        let mut services = Vec::new();
        
        for item in self.db.scan_prefix(prefix.as_bytes()) {
            let (_, value) = item.map_err(|e| Error::Storage(e.to_string()))?;
            let service: Service = serde_json::from_slice(&value)
                .map_err(|e| Error::Storage(e.to_string()))?;
            services.push(service);
        }
        
        Ok(services)
    }
}
$$--GLUE--$$
.\src\types.rs
$$--GLUE--$$
// src/types.rs

use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Storage error: {0}")]
    Storage(String),
    
    #[error("Service not found: {0}")]
    NotFound(String),
    
    #[error("Invalid request: {0}")]
    BadRequest(String),
    
    #[error("Raft error: {0}")]
    Raft(#[from] raft::Error),
    
    #[error("Auth error: {0}")]
    Auth(String),
    
    #[error("Rate limit exceeded")]
    RateLimit,

    #[error("Config error: {0}")]
    Config(String),

    #[error("Sled error: {0}")]
    Sled(#[from] sled::Error),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Service {
    pub id: String,
    pub name: String,
    pub address: String,
    pub port: u16,
    pub health_check_url: String,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
}

impl Service {
    pub fn new(name: String, address: String, port: u16) -> Self {
        let address_clone = address.clone();
        Self {
            id: Uuid::new_v4().to_string(),
            name,
            address,
            port,
            health_check_url: format!("http://{}:{}/health", address_clone, port),
            tags: Vec::new(),
            metadata: HashMap::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheck {
    pub status: HealthStatus,
    pub message: Option<String>,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}
$$--GLUE--$$
.\src\config.rs
$$--GLUE--$$
use config::{Config, ConfigError, File};
use serde::Deserialize;
use std::time::Duration;

#[derive(Debug, Deserialize, Clone)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

#[derive(Debug, Deserialize, Clone)]
pub struct SecurityConfig {
    pub jwt_secret: String,
    pub cert_path: String,
    pub key_path: String,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RaftConfig {
    pub node_id: u64,
    pub peers: Vec<u64>,
    pub election_timeout: u64,
    pub heartbeat_interval: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct CircuitBreakerConfig {
    pub failure_threshold: usize,
    pub reset_timeout: u64,
}

#[derive(Debug, Deserialize, Clone)]
pub struct RateLimitConfig {
    pub requests_per_minute: u32,
    pub burst: u32,
}

#[derive(Debug, Deserialize, Clone)]
pub struct Settings {
    pub server: ServerConfig,
    pub security: SecurityConfig,
    pub raft: RaftConfig,
    pub circuit_breaker: CircuitBreakerConfig,
    pub rate_limit: RateLimitConfig,
}

impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let mut config = Config::new();
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;
        config.merge(File::with_name("config/default"))?;
        config.merge(File::with_name("config/local").required(false))?;

        config.deserialize()
    }

    pub fn circuit_breaker_reset_timeout(&self) -> Duration {
        Duration::from_secs(self.circuit_breaker.reset_timeout)
    }

    pub fn raft_election_timeout(&self) -> Duration {
        Duration::from_millis(self.raft.election_timeout)
    }

    pub fn raft_heartbeat_interval(&self) -> Duration {
        Duration::from_millis(self.raft.heartbeat_interval)
    }
}
$$--GLUE--$$
.\src\consensus\mod.rs
$$--GLUE--$$
mod raft;
mod state;

pub use raft::RaftNode;
pub use state::RaftStorage;

$$--GLUE--$$
.\src\consensus\raft.rs
$$--GLUE--$$
use raft::{
    prelude::*,
    Config, RawNode, StateRole,
};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;
use super::state::RaftStorage;

pub struct RaftNode {
    id: u64,
    node: RawNode<RaftStorage>,
    store: Arc<Store>,
    logger: Logger,
}

impl RaftNode {
    pub fn new(
        id: u64,
        peers: Vec<u64>,
        store: Arc<Store>,
        logger: Logger,
    ) -> raft::Result<Self> {
        let config = Config {
            id,
            election_tick: 10,
            heartbeat_tick: 3,
            ..Default::default()
        };

        let storage = RaftStorage::new(store.clone(), logger.clone());
        let node = RawNode::new(&config, storage, &logger)?;

        Ok(Self { 
            id,
            node,
            store,
            logger,
        })
    }

    pub async fn tick(&mut self) {
        self.node.tick();
    }

    pub async fn propose(&mut self, data: Vec<u8>) -> raft::Result<()> {
        self.node.propose(vec![], data)?;
        Ok(())
    }

    pub async fn step(&mut self, msg: Message) -> raft::Result<()> {
        self.node.step(msg)?;
        Ok(())
    }

    pub async fn advance(&mut self) {
        self.node.advance(Ready::default());
    }

    pub async fn campaign(&mut self) -> raft::Result<()> {
        self.node.campaign()?;
        Ok(())
    }

    pub fn is_leader(&self) -> bool {
        self.node.raft.state == StateRole::Leader
    }
}
$$--GLUE--$$
.\src\consensus\state.rs
$$--GLUE--$$
use raft::prelude::*; // This includes all the necessary eraftpb types
use raft::{GetEntriesContext, RaftState, Result as RaftResult, Storage};
use slog::Logger;
use std::sync::Arc;
use crate::store::Store;

pub struct RaftStorage {
    store: Arc<Store>,
    hard_state: HardState,
    snapshot: Snapshot,
    logger: Logger,
}

impl RaftStorage {
    pub fn new(store: Arc<Store>, logger: Logger) -> Self {
        Self {
            store,
            hard_state: HardState::default(),
            snapshot: Snapshot::default(),
            logger,
        }
    }
}

impl Storage for RaftStorage {
    fn initial_state(&self) -> RaftResult<RaftState> {
        Ok(RaftState {
            hard_state: self.hard_state.clone(),
            conf_state: ConfState::default(),
        })
    }

    fn entries(
        &self,
        low: u64,
        high: u64,
        max_size: impl Into<Option<u64>>,
        context: GetEntriesContext,
    ) -> RaftResult<Vec<Entry>> {
        // Implement entry retrieval from storage
        Ok(vec![])
    }

    fn term(&self, idx: u64) -> RaftResult<u64> {
        // Implement term lookup
        Ok(0)
    }

    fn first_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn last_index(&self) -> RaftResult<u64> {
        Ok(1)
    }

    fn snapshot(&self, request_index: u64, to: u64) -> RaftResult<Snapshot> {
        Ok(self.snapshot.clone())
    }
}

$$--GLUE--$$
.\src\discovery.rs
$$--GLUE--$$
// src/discovery/mod.rs
use crate::types::{Result, Error, Service, HealthCheck, HealthStatus};
use crate::store::Store;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{self, Duration};
use reqwest;

pub struct ServiceRegistry {
    store: Arc<Store>,
    health_checks: RwLock<Vec<String>>,
}

impl ServiceRegistry {
    pub fn new(store: Arc<Store>) -> Self {
        let registry = Self {
            store,
            health_checks: RwLock::new(Vec::new()),
        };
        
        // Spawn health check task
        tokio::spawn(registry.clone().run_health_checks());
        
        registry
    }

    pub async fn register(&self, service: Service) -> Result<()> {
        self.store.set(&service.id, &service)?;
        
        let mut health_checks = self.health_checks.write().await;
        health_checks.push(service.id.clone());
        
        Ok(())
    }

    pub async fn deregister(&self, service_id: &str) -> Result<()> {
        self.store.delete(service_id)?;
        
        let mut health_checks = self.health_checks.write().await;
        if let Some(pos) = health_checks.iter().position(|id| id == service_id) {
            health_checks.remove(pos);
        }
        
        Ok(())
    }

    pub async fn get_service(&self, service_id: &str) -> Result<Option<Service>> {
        self.store.get(service_id)
    }

    pub async fn get_services_by_name(&self, name: &str) -> Result<Vec<Service>> {
        self.store.scan_prefix(&format!("service:{}", name))
    }

    async fn run_health_checks(self) {
        let mut interval = time::interval(Duration::from_secs(10));
        
        loop {
            interval.tick().await;
            
            let health_checks = self.health_checks.read().await;
            for service_id in health_checks.iter() {
                if let Ok(Some(service)) = self.store.get(service_id) {
                    let health = self.check_health(&service).await;
                    if health.status == HealthStatus::Unhealthy {
                        tracing::warn!("Service {} failed health check: {:?}", service_id, health.message);
                    }
                }
            }
        }
    }

    async fn check_health(&self, service: &Service) -> HealthCheck {
        match reqwest::get(&service.health_check_url).await {
            Ok(response) => HealthCheck {
                status: if response.status().is_success() { 
                    HealthStatus::Healthy 
                } else { 
                    HealthStatus::Unhealthy 
                },
                message: None,
                timestamp: chrono::Utc::now(),
            },
            Err(e) => HealthCheck {
                status: HealthStatus::Unhealthy,
                message: Some(e.to_string()),
                timestamp: chrono::Utc::now(),
            },
        }
    }
}

impl Clone for ServiceRegistry {
    fn clone(&self) -> Self {
        Self {
            store: Arc::clone(&self.store),
            health_checks: RwLock::new(Vec::new()),
        }
    }
}
$$--GLUE--$$
.\src\main.rs
$$--GLUE--$$
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::sync::RwLock;
use axum::serve;
use tokio::net::TcpListener;
use slog::{Logger, Drain};

mod config;
mod consensus;
mod discovery;
mod router;
mod security;
mod store;
mod types;

use crate::config::Settings;
use crate::consensus::RaftNode;
use crate::discovery::ServiceRegistry;
use crate::router::Router;
use crate::security::TlsConfig;
use crate::store::Store;
use crate::types::{Result, Error};

// Implement From for ConfigError using the proper path
impl From<::config::ConfigError> for Error {
    fn from(err: ::config::ConfigError) -> Self {
        Error::Config(err.to_string())
    }
}

// Implement From for std::net::AddrParseError
impl From<std::net::AddrParseError> for Error {
    fn from(err: std::net::AddrParseError) -> Self {
        Error::BadRequest(err.to_string())
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize tracing
    tracing_subscriber::fmt::init();

    // Initialize slog logger
    let decorator = slog_term::TermDecorator::new().build();
    let drain = slog_term::FullFormat::new(decorator).build().fuse();
    let drain = slog_async::Async::new(drain).build().fuse();
    let logger = Logger::root(drain, slog::o!());

    // Load configuration
    let settings = Settings::new()?;

    // Initialize the storage layer
    let store = Arc::new(Store::new("data")?);
    
    // Initialize Raft consensus
    let raft_node = Arc::new(RwLock::new(RaftNode::new(
        settings.raft.node_id,
        settings.raft.peers.clone(),
        store.clone(),
        logger.clone(),
    )?));
    
    // Initialize the service registry
    let registry = Arc::new(RwLock::new(ServiceRegistry::new(store.clone())));
    
    // Initialize TLS
    let tls_config = TlsConfig::new(
        &settings.security.cert_path,
        &settings.security.key_path,
    )?;
    
    // Initialize the router with all features
    let app = Router::new(registry.clone());

    // Start Raft ticker
    let raft_clone = raft_node.clone();
    let settings_clone = settings.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(settings_clone.raft_heartbeat_interval());
        loop {
            interval.tick().await;
            let mut node = raft_clone.write().await;
        }
    });

    // Start the HTTP server
    let addr = SocketAddr::new(
        settings.server.host.parse()?,
        settings.server.port,
    );
    
    tracing::info!("Starting server on {}", addr);
    
    // Create TcpListener
    let listener = TcpListener::bind(addr).await?;
    let acceptor = tls_config.get_acceptor();
    
    serve(
        listener,
        app.into_make_service()
    )
    .await?;

    Ok(())
}
$$--GLUE--$$
.\src\router\balancer.rs
$$--GLUE--$$
use rand::seq::SliceRandom;
use std::sync::Arc;
use dashmap::DashMap;
use crate::types::Service;

#[derive(Debug, Clone)]
pub struct LoadBalancer {
    services: Arc<DashMap<String, Vec<Service>>>,
}

impl LoadBalancer {
    pub fn new() -> Self {
        Self {
            services: Arc::new(DashMap::new()),
        }
    }

    pub fn add_service(&self, service: Service) {
        self.services
            .entry(service.name.clone())
            .or_default()
            .push(service);
    }

    pub fn get_service(&self, name: &str) -> Option<Service> {
        self.services.get(name).and_then(|services| {
            services.choose(&mut rand::thread_rng()).cloned()
        })
    }
}
$$--GLUE--$$
.\src\router\cache.rs
$$--GLUE--$$
use std::time::Duration;
use moka::future::Cache;
use crate::types::Service;

pub struct RouteCache {
    cache: Cache<String, Vec<Service>>,
}

impl RouteCache {
    pub fn new() -> Self {
        Self {
            cache: Cache::builder()
                .time_to_live(Duration::from_secs(30))
                .time_to_idle(Duration::from_secs(10))
                .max_capacity(100)
                .build(),
        }
    }

    pub async fn get(&self, key: &str) -> Option<Vec<Service>> {
        self.cache.get(key).await
    }

    pub async fn insert(&self, key: String, value: Vec<Service>) {
        self.cache.insert(key, value).await;
    }

    pub async fn invalidate(&self, key: &str) {
        self.cache.invalidate(key).await;
    }
}

impl Default for RouteCache {
    fn default() -> Self {
        Self::new()
    }
}
$$--GLUE--$$
.\src\router\circuit_breaker.rs
$$--GLUE--$$
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::{Duration, Instant};
use tokio::sync::RwLock;

pub struct CircuitBreaker {
    failure_threshold: usize,
    reset_timeout: Duration,
    failures: AtomicUsize,
    last_failure: RwLock<Option<Instant>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: usize, reset_timeout: Duration) -> Self {
        Self {
            failure_threshold,
            reset_timeout,
            failures: AtomicUsize::new(0),
            last_failure: RwLock::new(None),
        }
    }

    pub async fn record_success(&self) {
        self.failures.store(0, Ordering::SeqCst);
        *self.last_failure.write().await = None;
    }

    pub async fn record_failure(&self) -> bool {
        let failures = self.failures.fetch_add(1, Ordering::SeqCst) + 1;
        *self.last_failure.write().await = Some(Instant::now());
        failures >= self.failure_threshold
    }

    pub async fn is_open(&self) -> bool {
        let failures = self.failures.load(Ordering::SeqCst);
        if failures < self.failure_threshold {
            return false;
        }

        if let Some(last_failure) = *self.last_failure.read().await {
            if last_failure.elapsed() > self.reset_timeout {
                self.failures.store(0, Ordering::SeqCst);
                return false;
            }
        }

        true
    }
}

$$--GLUE--$$
.\src\router\mod.rs
$$--GLUE--$$
mod routes;
mod balancer;
mod circuit_breaker;
mod cache;
mod websocket;

pub use routes::Router;
pub use balancer::LoadBalancer;
pub use circuit_breaker::CircuitBreaker;
pub use cache::RouteCache;
pub use websocket::WebSocketHandler;
$$--GLUE--$$
.\src\router\routes.rs
$$--GLUE--$$
use axum::{
    Router as AxumRouter,
    routing::{get, post, delete},
    extract::{State, Path},
    Json,
    response::IntoResponse,
    http::StatusCode,
};
use std::sync::Arc;
use tokio::sync::RwLock;
use crate::{
    discovery::ServiceRegistry,
    types::{Service, Error},
};

pub struct Router {
    registry: Arc<RwLock<ServiceRegistry>>,
}

impl Router {
    pub fn new(registry: Arc<RwLock<ServiceRegistry>>) -> AxumRouter {
        let shared_state = Arc::new(Self { registry });

        AxumRouter::new()
            .route("/services", post(Self::register_service))
            .route("/services/:id", get(Self::get_service))
            .route("/services/:id", delete(Self::deregister_service))
            .with_state(shared_state)
    }

    async fn register_service(
        State(state): State<Arc<Router>>,
        Json(service): Json<Service>,
    ) -> Result<(StatusCode, Json<Service>), Error> {
        state.registry.write().await.register(service.clone()).await?;
        Ok((StatusCode::CREATED, Json(service)))
    }

    async fn get_service(
        State(state): State<Arc<Router>>,
        Path(id): Path<String>,
    ) -> Result<Json<Option<Service>>, Error> {
        let service = state.registry.read().await.get_service(&id).await?;
        Ok(Json(service))
    }

    async fn deregister_service(
        State(state): State<Arc<Router>>,
        Path(id): Path<String>,
    ) -> Result<StatusCode, Error> {
        state.registry.write().await.deregister(&id).await?;
        Ok(StatusCode::NO_CONTENT)
    }
}

// Implement IntoResponse for Error to properly handle errors
impl IntoResponse for Error {
    fn into_response(self) -> axum::response::Response {
        let status = match self {
            Error::NotFound(_) => StatusCode::NOT_FOUND,
            Error::BadRequest(_) => StatusCode::BAD_REQUEST,
            Error::Auth(_) => StatusCode::UNAUTHORIZED,
            Error::RateLimit => StatusCode::TOO_MANY_REQUESTS,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        };
        (status, self.to_string()).into_response()
    }
}
$$--GLUE--$$
.\src\router\websocket.rs
$$--GLUE--$$
use axum::{
    extract::ws::{WebSocket, WebSocketUpgrade},
    response::Response,
};
use futures::{sink::SinkExt, stream::StreamExt};

pub struct WebSocketHandler;

impl WebSocketHandler {
    pub async fn handle_upgrade(ws: WebSocketUpgrade) -> Response {
        ws.on_upgrade(Self::handle_socket)
    }

    async fn handle_socket(mut socket: WebSocket) {
        while let Some(msg) = socket.recv().await {
            if let Ok(msg) = msg {
                if socket.send(msg).await.is_err() {
                    break;
                }
            } else {
                break;
            }
        }
    }
}
$$--GLUE--$$
.\src\security\auth.rs
$$--GLUE--$$
use axum::{
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
    body::Body,
};
use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,
    exp: u64,
    role: String,
}

pub async fn authenticate(
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = req
        .headers()
        .get("Authorization")
        .and_then(|header| header.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    if !auth_header.starts_with("Bearer ") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    let token = &auth_header["Bearer ".len()..];
    let key = DecodingKey::from_secret(b"your-secret-key"); // In production, use proper key management
    
    let validation = Validation::new(Algorithm::HS256);
    let claims = decode::<Claims>(token, &key, &validation)
        .map_err(|_| StatusCode::UNAUTHORIZED)?
        .claims;

    // Check token expiration
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs();
    
    if claims.exp < now {
        return Err(StatusCode::UNAUTHORIZED);
    }

    Ok(next.run(req).await)
}

pub async fn authorize(
    req: Request<Body>,
    next: Next,
) -> Result<Response, StatusCode> {
    // Implement role-based access control here
    Ok(next.run(req).await)
}
$$--GLUE--$$
.\src\security\mod.rs
$$--GLUE--$$
mod tls;
mod auth;
mod rate_limit;

pub use tls::TlsConfig;
pub use auth::{authenticate, authorize};
pub use rate_limit::rate_limit;

$$--GLUE--$$
.\src\security\rate_limit.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use std::time::{Instant, Duration};
use tower::limit::RateLimitLayer;
use tower::ServiceBuilder;

#[derive(Clone)]
pub struct RateLimiter {
    requests: Arc<Mutex<HashMap<String, Vec<Instant>>>>,
    max_requests: usize,
    window: Duration,
}

impl RateLimiter {
    pub fn new(max_requests: usize, window: Duration) -> Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
            max_requests,
            window,
        }
    }

    pub async fn check_rate_limit(&self, key: &str) -> bool {
        let mut requests = self.requests.lock().await;
        let now = Instant::now();
        
        // Clean up old requests
        requests.entry(key.to_string())
            .and_modify(|reqs| {
                reqs.retain(|&time| now.duration_since(time) < self.window);
            })
            .or_insert_with(Vec::new);
            
        let current_requests = requests.get(key).unwrap();
        
        if current_requests.len() >= self.max_requests {
            false
        } else {
            requests.get_mut(key).unwrap().push(now);
            true
        }
    }
}

pub fn rate_limit() -> RateLimitLayer {
    RateLimitLayer::new(
        50, // requests
        Duration::from_secs(60), // per minute
    )
}
$$--GLUE--$$
.\src\security\tls.rs
$$--GLUE--$$
use std::sync::Arc;
use tokio_rustls::rustls::{
    Certificate, PrivateKey,
    ServerConfig as RustlsServerConfig,
};
use tokio_rustls::TlsAcceptor;

pub struct TlsConfig {
    acceptor: TlsAcceptor,
}

impl TlsConfig {
    pub fn new(cert_path: &str, key_path: &str) -> std::io::Result<Self> {
        let certs = load_certs(cert_path)?;
        let key = load_private_key(key_path)?;
        
        let config = RustlsServerConfig::builder()
            .with_safe_defaults()
            .with_no_client_auth()
            .with_single_cert(certs, key)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
            
        Ok(Self {
            acceptor: TlsAcceptor::from(Arc::new(config)),
        })
    }

    pub fn get_acceptor(&self) -> TlsAcceptor {
        self.acceptor.clone()
    }
}

fn load_certs(path: &str) -> std::io::Result<Vec<Certificate>> {
    let cert_file = std::fs::read(path)?;
    let certs = rustls_pemfile::certs(&mut &cert_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load certificate"
        ))?
        .into_iter()
        .map(Certificate)
        .collect();
    Ok(certs)
}

fn load_private_key(path: &str) -> std::io::Result<PrivateKey> {
    let key_file = std::fs::read(path)?;
    let key = rustls_pemfile::pkcs8_private_keys(&mut &key_file[..])
        .map_err(|_| std::io::Error::new(
            std::io::ErrorKind::Other,
            "failed to load private key"
        ))?
        .into_iter()
        .next()
        .ok_or_else(|| std::io::Error::new(
            std::io::ErrorKind::Other,
            "no private key found"
        ))?;
    Ok(PrivateKey(key))
}
$$--GLUE--$$
.\src\store.rs
$$--GLUE--$$
// src/store/mod.rs
use crate::types::{Result, Error, Service};
use sled::Db;
use std::path::Path;
use serde_json;

pub struct Store {
    db: Db,
}

impl Store {
    pub fn new<P: AsRef<Path>>(path: P) -> Result<Self> {
        let db = sled::open(path)?;
        Ok(Self { db })
    }

    pub fn set(&self, key: &str, value: &Service) -> Result<()> {
        let serialized = serde_json::to_vec(value)
            .map_err(|e| Error::Storage(e.to_string()))?;
        
        self.db
            .insert(key.as_bytes(), serialized)
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn get(&self, key: &str) -> Result<Option<Service>> {
        if let Some(data) = self.db.get(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))? {
            let service: Service = serde_json::from_slice(&data)
                .map_err(|e| Error::Storage(e.to_string()))?;
            Ok(Some(service))
        } else {
            Ok(None)
        }
    }

    pub fn delete(&self, key: &str) -> Result<()> {
        self.db
            .remove(key.as_bytes())
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        self.db
            .flush()
            .map_err(|e| Error::Storage(e.to_string()))?;
            
        Ok(())
    }

    pub fn scan_prefix(&self, prefix: &str) -> Result<Vec<Service>> {
        let mut services = Vec::new();
        
        for item in self.db.scan_prefix(prefix.as_bytes()) {
            let (_, value) = item.map_err(|e| Error::Storage(e.to_string()))?;
            let service: Service = serde_json::from_slice(&value)
                .map_err(|e| Error::Storage(e.to_string()))?;
            services.push(service);
        }
        
        Ok(services)
    }
}
$$--GLUE--$$
.\src\types.rs
$$--GLUE--$$
// src/types.rs

use serde::{Deserialize, Serialize};
use thiserror::Error;
use uuid::Uuid;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Error, Debug)]
pub enum Error {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Storage error: {0}")]
    Storage(String),
    
    #[error("Service not found: {0}")]
    NotFound(String),
    
    #[error("Invalid request: {0}")]
    BadRequest(String),
    
    #[error("Raft error: {0}")]
    Raft(#[from] raft::Error),
    
    #[error("Auth error: {0}")]
    Auth(String),
    
    #[error("Rate limit exceeded")]
    RateLimit,

    #[error("Config error: {0}")]
    Config(String),

    #[error("Sled error: {0}")]
    Sled(#[from] sled::Error),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Service {
    pub id: String,
    pub name: String,
    pub address: String,
    pub port: u16,
    pub health_check_url: String,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
}

impl Service {
    pub fn new(name: String, address: String, port: u16) -> Self {
        let address_clone = address.clone();
        Self {
            id: Uuid::new_v4().to_string(),
            name,
            address,
            port,
            health_check_url: format!("http://{}:{}/health", address_clone, port),
            tags: Vec::new(),
            metadata: HashMap::new(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheck {
    pub status: HealthStatus,
    pub message: Option<String>,
    #[serde(with = "chrono::serde::ts_seconds")]
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}